{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emperator Technical Brief \u00b6 Emperator turns software standards into an executable contract that continuously audits, fixes, and scaffolds code across polyglot projects. This brief follows the Di\u00e1taxis framework so you can ramp up quickly, apply the platform in day-to-day workflows, understand the system internals, and cite precise specifications when needed. Onboard fast: Start with the tutorial to install the CLI, compile your first contract, and experience the safety loop locally before involving CI. Operationalize standards: Use the how-to guides for contract authoring, pipeline integration, and responsible AI-assisted refactors. Understand the why: The explanation deep dive maps the Contract\u2192IR\u2192Action pipeline, safety envelope, and extensibility points. Reference details: Consult the reference section for rule schemas, toolchain support matrices, SBOM and audit artifacts, and Copilot prompt packs. Copilot tip: Add docs/includes/copilot-prompts.md to your prompt library so the assistant can surface project-aware scaffolds and review checklists while you work.","title":"Home"},{"location":"#emperator-technical-brief","text":"Emperator turns software standards into an executable contract that continuously audits, fixes, and scaffolds code across polyglot projects. This brief follows the Di\u00e1taxis framework so you can ramp up quickly, apply the platform in day-to-day workflows, understand the system internals, and cite precise specifications when needed. Onboard fast: Start with the tutorial to install the CLI, compile your first contract, and experience the safety loop locally before involving CI. Operationalize standards: Use the how-to guides for contract authoring, pipeline integration, and responsible AI-assisted refactors. Understand the why: The explanation deep dive maps the Contract\u2192IR\u2192Action pipeline, safety envelope, and extensibility points. Reference details: Consult the reference section for rule schemas, toolchain support matrices, SBOM and audit artifacts, and Copilot prompt packs. Copilot tip: Add docs/includes/copilot-prompts.md to your prompt library so the assistant can surface project-aware scaffolds and review checklists while you work.","title":"Emperator Technical Brief"},{"location":"explanation/ai-orchestration/","text":"AI-Orchestrated Refactoring \u00b6 Optional AI assistance augments Emperator\u2019s deterministic pipeline when rule-based codemods are insufficient, while strict validation keeps proposals safe. Propose \u2192 rank \u2192 validate workflow \u00b6 Propose: Emperator crafts prompts with rule context, offending code, and acceptance tests to solicit candidate patches from a local LLM. Rank: Contract-aware heuristics (diff size, naming compliance, static lint) filter and order candidates before deeper checks. Validate: The leading candidate is applied in a scratch workspace, rerun through Emperator\u2019s full analysis suite, and optionally tested. Only clean results surface to developers. Local-first model strategy \u00b6 Favors on-prem, open-weight models such as Code Llama, StarCoder, or Phi-3 to avoid leaking proprietary code. Stores model metadata, prompt hashes, and outputs for provenance so reviewers know when AI contributed to a change. Allows teams to swap or fine-tune models as new, higher-quality releases appear without altering the orchestration layer. Use cases \u00b6 Complex deprecations where templated codemods fall short; AI suggests migrations that preserve behaviour and formatting. Contract-driven scaffolding (e.g., generating controller stubs from OpenAPI paths) beyond simple text templates. Documentation upkeep, such as drafting docstrings or changelog entries tied to rule updates for human refinement. Guardrails against hallucinations \u00b6 AI-generated diffs must satisfy the same static analysis, tests, and safety tier checks as human-authored code; failures discard the suggestion. Provenance comments embed model version and prompt id, enabling audits and post-mortem analysis. Teams can restrict AI usage to advisory mode, requiring manual application of any suggested patches. Continuous improvement \u00b6 Capture rejected proposals to refine prompts, adjust model temperature, or retrain with organization-specific patterns. Package successful AI-assisted migrations as formal codemod recipes so future occurrences bypass the model entirely. With a tightly controlled feedback loop, AI becomes a force multiplier for large-scale refactors without weakening Emperator\u2019s compliance and safety guarantees.","title":"AI-Orchestrated Refactoring"},{"location":"explanation/ai-orchestration/#ai-orchestrated-refactoring","text":"Optional AI assistance augments Emperator\u2019s deterministic pipeline when rule-based codemods are insufficient, while strict validation keeps proposals safe.","title":"AI-Orchestrated Refactoring"},{"location":"explanation/ai-orchestration/#propose-rank-validate-workflow","text":"Propose: Emperator crafts prompts with rule context, offending code, and acceptance tests to solicit candidate patches from a local LLM. Rank: Contract-aware heuristics (diff size, naming compliance, static lint) filter and order candidates before deeper checks. Validate: The leading candidate is applied in a scratch workspace, rerun through Emperator\u2019s full analysis suite, and optionally tested. Only clean results surface to developers.","title":"Propose \u2192 rank \u2192 validate workflow"},{"location":"explanation/ai-orchestration/#local-first-model-strategy","text":"Favors on-prem, open-weight models such as Code Llama, StarCoder, or Phi-3 to avoid leaking proprietary code. Stores model metadata, prompt hashes, and outputs for provenance so reviewers know when AI contributed to a change. Allows teams to swap or fine-tune models as new, higher-quality releases appear without altering the orchestration layer.","title":"Local-first model strategy"},{"location":"explanation/ai-orchestration/#use-cases","text":"Complex deprecations where templated codemods fall short; AI suggests migrations that preserve behaviour and formatting. Contract-driven scaffolding (e.g., generating controller stubs from OpenAPI paths) beyond simple text templates. Documentation upkeep, such as drafting docstrings or changelog entries tied to rule updates for human refinement.","title":"Use cases"},{"location":"explanation/ai-orchestration/#guardrails-against-hallucinations","text":"AI-generated diffs must satisfy the same static analysis, tests, and safety tier checks as human-authored code; failures discard the suggestion. Provenance comments embed model version and prompt id, enabling audits and post-mortem analysis. Teams can restrict AI usage to advisory mode, requiring manual application of any suggested patches.","title":"Guardrails against hallucinations"},{"location":"explanation/ai-orchestration/#continuous-improvement","text":"Capture rejected proposals to refine prompts, adjust model temperature, or retrain with organization-specific patterns. Package successful AI-assisted migrations as formal codemod recipes so future occurrences bypass the model entirely. With a tightly controlled feedback loop, AI becomes a force multiplier for large-scale refactors without weakening Emperator\u2019s compliance and safety guarantees.","title":"Continuous improvement"},{"location":"explanation/developer-experience/","text":"Developer Experience Integration \u00b6 Emperator is designed to feel like a teammate that automates busywork while keeping developers in control. This overview highlights key workflow touchpoints. One-command ergonomics \u00b6 emperor apply defaults to a dry run that lists checks, fixes, and suggestions so developers can review diffs before committing. Rich console output cites rule IDs, contract evidence, and remediation steps, turning enforcement into a learning moment instead of a cryptic failure. Exit codes align with CI expectations ( 0 clean, 1 violations remaining) so Emperator slots into existing automation easily. Git-native workflows \u00b6 Pre-commit integration ( entry: emperor apply --diff --color ) keeps local commits compliant without manual linting. CI pipelines can run fast ( --fast ) or full ( --strict ) modes and upload SARIF for inline review comments. Auto-applied fixes carry provenance markers (rule id, contract version) in commit messages, making audit trails obvious. Editor feedback loops \u00b6 The optional LSP server surfaces contract violations as diagnostics and offers quick fixes when codemods are available. VS Code and other LSP-aware editors can trigger Emperator on save, providing near-real-time feedback backed by Tree-sitter\u2019s incremental parsing. Snippets and commands scaffold new modules or handlers based on OpenAPI and contract templates to accelerate feature startup. Config minimalism \u00b6 The Project Contract is the single source of configuration; Emperator infers tool settings (formatters, Semgrep rule packs, CodeQL queries) automatically. Profiles let teams roll out enforcement gradually\u2014warn-only for newcomers, strict mode for protected branches. Verbose logs and dry-run modes help teams debug new rules before flipping them to blocking status. Language tooling \u00b6 Emperator installs formatter and lint stacks per language as defined in the Toolchain Matrix , keeping local editors and CI pipelines aligned. Contract metadata advertises which tools run automatically, so teams can configure editor integrations (e.g., Ruff or Prettier on save) without guessing. Language owners can enable experimental analyzers behind profiles, gradually rolling them out as developers provide feedback. Respecting developer time \u00b6 Incremental analysis daemons cache IR so routine runs complete in seconds even on large codebases. Idempotent codemods and formatter passes prevent noisy diffs, keeping pull requests focused on substantive changes. Clear waiver workflows and rule ownership metadata ensure developers know exactly whom to involve when they need exceptions. A smooth developer experience is foundational to adoption; Emperator\u2019s tooling aims to reduce friction so teams can spend energy on product work rather than policing standards manually. Consult the Developer Tooling reference when provisioning workstations or Dev Containers.","title":"Developer Experience Integration"},{"location":"explanation/developer-experience/#developer-experience-integration","text":"Emperator is designed to feel like a teammate that automates busywork while keeping developers in control. This overview highlights key workflow touchpoints.","title":"Developer Experience Integration"},{"location":"explanation/developer-experience/#one-command-ergonomics","text":"emperor apply defaults to a dry run that lists checks, fixes, and suggestions so developers can review diffs before committing. Rich console output cites rule IDs, contract evidence, and remediation steps, turning enforcement into a learning moment instead of a cryptic failure. Exit codes align with CI expectations ( 0 clean, 1 violations remaining) so Emperator slots into existing automation easily.","title":"One-command ergonomics"},{"location":"explanation/developer-experience/#git-native-workflows","text":"Pre-commit integration ( entry: emperor apply --diff --color ) keeps local commits compliant without manual linting. CI pipelines can run fast ( --fast ) or full ( --strict ) modes and upload SARIF for inline review comments. Auto-applied fixes carry provenance markers (rule id, contract version) in commit messages, making audit trails obvious.","title":"Git-native workflows"},{"location":"explanation/developer-experience/#editor-feedback-loops","text":"The optional LSP server surfaces contract violations as diagnostics and offers quick fixes when codemods are available. VS Code and other LSP-aware editors can trigger Emperator on save, providing near-real-time feedback backed by Tree-sitter\u2019s incremental parsing. Snippets and commands scaffold new modules or handlers based on OpenAPI and contract templates to accelerate feature startup.","title":"Editor feedback loops"},{"location":"explanation/developer-experience/#config-minimalism","text":"The Project Contract is the single source of configuration; Emperator infers tool settings (formatters, Semgrep rule packs, CodeQL queries) automatically. Profiles let teams roll out enforcement gradually\u2014warn-only for newcomers, strict mode for protected branches. Verbose logs and dry-run modes help teams debug new rules before flipping them to blocking status.","title":"Config minimalism"},{"location":"explanation/developer-experience/#language-tooling","text":"Emperator installs formatter and lint stacks per language as defined in the Toolchain Matrix , keeping local editors and CI pipelines aligned. Contract metadata advertises which tools run automatically, so teams can configure editor integrations (e.g., Ruff or Prettier on save) without guessing. Language owners can enable experimental analyzers behind profiles, gradually rolling them out as developers provide feedback.","title":"Language tooling"},{"location":"explanation/developer-experience/#respecting-developer-time","text":"Incremental analysis daemons cache IR so routine runs complete in seconds even on large codebases. Idempotent codemods and formatter passes prevent noisy diffs, keeping pull requests focused on substantive changes. Clear waiver workflows and rule ownership metadata ensure developers know exactly whom to involve when they need exceptions. A smooth developer experience is foundational to adoption; Emperator\u2019s tooling aims to reduce friction so teams can spend energy on product work rather than policing standards manually. Consult the Developer Tooling reference when provisioning workstations or Dev Containers.","title":"Respecting developer time"},{"location":"explanation/devsecops-supply-chain/","text":"DevSecOps and Supply Chain Integration \u00b6 Emperator embeds compliance and supply chain security controls into everyday development activities so provenance, SBOMs, and policy enforcement stay in lockstep with code changes. SBOM discipline and dependency guardrails \u00b6 Generate application SBOMs with emperor sbom --format cyclonedx --output sbom/app.json and merge them with base image or infrastructure BOMs to achieve full-stack visibility. Enforce license allowlists and dependency age thresholds by evaluating SBOM metadata through Rego policies. Feed generated SBOMs into vulnerability scanners such as Dependency-Track or Microsoft Defender for continuous monitoring and alerting. Provenance and SLSA alignment \u00b6 Emit in-toto attestations via emperor attest --out provenance/intoto.jsonl ; sign them using Sigstore Cosign or internal PKI to establish a verifiable build record. Attach signed attestations and SBOMs to release artefacts so auditors can confirm the contract version, Emperator build version, and rule set applied. Keep the Project Contract versioned to provide a transparent change log for every standards update. Policy as code everywhere \u00b6 Store compliance logic in contract/policy/*.rego so the same rules can gate commits, CI pipelines, and runtime environments. Triangulate Semgrep, CodeQL, and Rego findings to reduce false positives and provide evidence-backed enforcement for security-critical policies. Configure rule severities and safety tiers to phase in new mandates gradually (warn \u2192 block) without overwhelming legacy codebases. Infrastructure-as-code guardrails \u00b6 Enforce Terraform best practices with terraform fmt and tflint , keeping configurations aligned with the Toolchain Matrix . Validate Kubernetes YAML and Helm charts using contract-aware OpenRewrite recipes plus Semgrep policies to prevent privilege escalation and drift. Require SBOM and attestation artefacts for infrastructure modules so platform teams can track IaC provenance alongside application deployments. Sandbox-friendly execution \u00b6 Package Emperator and its dependencies inside offline-friendly containers so classified or air-gapped environments can run the full pipeline with no external calls. Cache Semgrep and CodeQL databases between runs to maintain performance while respecting restricted network policies. Run optional dynamic checks (e.g., property-based tests) inside hardened temporary directories to limit exposure when executing user code. Exemption governance and reporting \u00b6 Record waivers in contract/exemptions.yaml with owner, expiry, and mitigation notes; Emperator can fail builds when waivers lapse or lack justification. Export waiver reports ( emperor explain --exemptions --format table ) for compliance dashboards and recurring review cadences. Require review comments to reference rule IDs so accepted risk is always traceable to the originating standard. By treating supply chain signals as first-class artefacts, Emperator keeps code, policies, and audit evidence synchronized\u2014helping teams reach higher SLSA tiers without bolting on one-off scripts.","title":"DevSecOps and Supply Chain"},{"location":"explanation/devsecops-supply-chain/#devsecops-and-supply-chain-integration","text":"Emperator embeds compliance and supply chain security controls into everyday development activities so provenance, SBOMs, and policy enforcement stay in lockstep with code changes.","title":"DevSecOps and Supply Chain Integration"},{"location":"explanation/devsecops-supply-chain/#sbom-discipline-and-dependency-guardrails","text":"Generate application SBOMs with emperor sbom --format cyclonedx --output sbom/app.json and merge them with base image or infrastructure BOMs to achieve full-stack visibility. Enforce license allowlists and dependency age thresholds by evaluating SBOM metadata through Rego policies. Feed generated SBOMs into vulnerability scanners such as Dependency-Track or Microsoft Defender for continuous monitoring and alerting.","title":"SBOM discipline and dependency guardrails"},{"location":"explanation/devsecops-supply-chain/#provenance-and-slsa-alignment","text":"Emit in-toto attestations via emperor attest --out provenance/intoto.jsonl ; sign them using Sigstore Cosign or internal PKI to establish a verifiable build record. Attach signed attestations and SBOMs to release artefacts so auditors can confirm the contract version, Emperator build version, and rule set applied. Keep the Project Contract versioned to provide a transparent change log for every standards update.","title":"Provenance and SLSA alignment"},{"location":"explanation/devsecops-supply-chain/#policy-as-code-everywhere","text":"Store compliance logic in contract/policy/*.rego so the same rules can gate commits, CI pipelines, and runtime environments. Triangulate Semgrep, CodeQL, and Rego findings to reduce false positives and provide evidence-backed enforcement for security-critical policies. Configure rule severities and safety tiers to phase in new mandates gradually (warn \u2192 block) without overwhelming legacy codebases.","title":"Policy as code everywhere"},{"location":"explanation/devsecops-supply-chain/#infrastructure-as-code-guardrails","text":"Enforce Terraform best practices with terraform fmt and tflint , keeping configurations aligned with the Toolchain Matrix . Validate Kubernetes YAML and Helm charts using contract-aware OpenRewrite recipes plus Semgrep policies to prevent privilege escalation and drift. Require SBOM and attestation artefacts for infrastructure modules so platform teams can track IaC provenance alongside application deployments.","title":"Infrastructure-as-code guardrails"},{"location":"explanation/devsecops-supply-chain/#sandbox-friendly-execution","text":"Package Emperator and its dependencies inside offline-friendly containers so classified or air-gapped environments can run the full pipeline with no external calls. Cache Semgrep and CodeQL databases between runs to maintain performance while respecting restricted network policies. Run optional dynamic checks (e.g., property-based tests) inside hardened temporary directories to limit exposure when executing user code.","title":"Sandbox-friendly execution"},{"location":"explanation/devsecops-supply-chain/#exemption-governance-and-reporting","text":"Record waivers in contract/exemptions.yaml with owner, expiry, and mitigation notes; Emperator can fail builds when waivers lapse or lack justification. Export waiver reports ( emperor explain --exemptions --format table ) for compliance dashboards and recurring review cadences. Require review comments to reference rule IDs so accepted risk is always traceable to the originating standard. By treating supply chain signals as first-class artefacts, Emperator keeps code, policies, and audit evidence synchronized\u2014helping teams reach higher SLSA tiers without bolting on one-off scripts.","title":"Exemption governance and reporting"},{"location":"explanation/executive-summary/","text":"Executive Summary \u00b6 Emperator turns your software standards into enforceable automation that keeps codebases secure, consistent, and audit-ready. The platform compiles a versioned Project Contract into multi-language analysis, deterministic codemods, and scaffolded assets so teams can adopt best practices without slowing delivery. Why Emperator \u00b6 Unified Contract \u2192 IR \u2192 Action loop: Encode expectations once and let Emperator translate them into checks, fixes, and generators across every repository. Evidence-backed assurance: Triangulated findings (Tree-sitter, Semgrep, CodeQL) and signed provenance artefacts give auditors confidence in rule enforcement. Developer-first experience: Pre-commit hooks, LSP diagnostics, and precise diffs make compliance part of the normal workflow rather than an afterthought. Supply chain integrity: Automatic SBOMs, in-toto attestations, and policy-as-code keep releases aligned with SLSA targets. Safe automation: Safety tiers, property-based testing, and rollback guarantees ensure that auto-applied changes never surprise reviewers. Key capabilities at a glance \u00b6 Capability Highlights Docs Contract authoring OpenAPI, CUE, Rego scaffolds, review workflow how-to/author-contract.md Static analysis Polyglot IR, curated rule packs, AI-augmented suggestions explanation/system-architecture.md, reference/toolchain.md Automation & CI Pre-commit integration, pipeline templates, SBOM/provenance tutorial/getting-started.md, how-to/ci-integration.md Governance Waiver audits, compliance checklist, signed artefacts reference/governance.md, explanation/devsecops-supply-chain.md AI assistance Local-model propose \u2192 rank \u2192 validate loop how-to/ai-assisted-refactors.md, explanation/ai-orchestration.md Executive visuals \u00b6 flowchart LR subgraph Contract Governance A[Project Contract<br/>Versioned Standards] B[Evidence & Rationale] end subgraph Automation Engine C[Universal IR<br/>Tree-sitter \u2022 CodeQL \u2022 Semgrep] D[Deterministic Codemods Safety Gate] end subgraph Business Outcomes E[Faster Reviews<br/>Policy Compliance] F[Audit-Ready Releases<br/>Provable SBOM & Attestation] G[Developer Productivity<br/>Less Manual Rework] end A --> C --> D --> E B --> C D --> F D --> G timeline title Emperator Adoption Timeline phase One: Foundation month 1 : Check-only mode in CI month 1 : Tutorial pilot repo onboarded phase Two: Automation month 2 : Formatting + low-risk codemods auto-applied month 2 : SBOM + provenance artefacts published phase Three: Expansion month 3 : Strict gating on critical rules month 3 : AI-assisted migrations enabled with validation loop phase Four: Governance month 4 : Waiver reviews automated month 4 : Executive dashboards and evidence packs delivered Adopt Emperator Gradually Start in check-only mode: Run emperor check --format sarif in CI to surface gaps without blocking merges. Pilot auto-fixes on low-risk rules: Enable formatting and trivial codemods in a staging repo; confirm tests stay green. Expand coverage iteratively: Promote rules to --strict once teams trust the output, then introduce higher-tier codemods with safety gating. Instrument metrics: Track violations resolved, runtime, and waiver trends to prove ROI and identify where to invest next. Recommended rollout narrative \u00b6 Assess the baseline: Use the tutorial to index an existing project, reviewing the initial findings report with architecture and security leads. Define success metrics: Agree on target reduction in manual review comments, critical security findings, or dependency drift. Automate the pipeline: Integrate the CI template, generate SBOM/provenance artefacts, and ensure stakeholders can access the reports. Enable AI with guardrails: Once deterministic automation is stable, opt in to AI-assisted refactors for complex migrations, keeping validation in place. Operationalize governance: Schedule recurring waiver reviews, sign releases, and store evidence packs for audits\u2014completing the contract-as-code loop. Use this summary to brief executives, security stakeholders, or new team members before diving into the detailed sections of the technical brief.","title":"Executive Summary"},{"location":"explanation/executive-summary/#executive-summary","text":"Emperator turns your software standards into enforceable automation that keeps codebases secure, consistent, and audit-ready. The platform compiles a versioned Project Contract into multi-language analysis, deterministic codemods, and scaffolded assets so teams can adopt best practices without slowing delivery.","title":"Executive Summary"},{"location":"explanation/executive-summary/#why-emperator","text":"Unified Contract \u2192 IR \u2192 Action loop: Encode expectations once and let Emperator translate them into checks, fixes, and generators across every repository. Evidence-backed assurance: Triangulated findings (Tree-sitter, Semgrep, CodeQL) and signed provenance artefacts give auditors confidence in rule enforcement. Developer-first experience: Pre-commit hooks, LSP diagnostics, and precise diffs make compliance part of the normal workflow rather than an afterthought. Supply chain integrity: Automatic SBOMs, in-toto attestations, and policy-as-code keep releases aligned with SLSA targets. Safe automation: Safety tiers, property-based testing, and rollback guarantees ensure that auto-applied changes never surprise reviewers.","title":"Why Emperator"},{"location":"explanation/executive-summary/#key-capabilities-at-a-glance","text":"Capability Highlights Docs Contract authoring OpenAPI, CUE, Rego scaffolds, review workflow how-to/author-contract.md Static analysis Polyglot IR, curated rule packs, AI-augmented suggestions explanation/system-architecture.md, reference/toolchain.md Automation & CI Pre-commit integration, pipeline templates, SBOM/provenance tutorial/getting-started.md, how-to/ci-integration.md Governance Waiver audits, compliance checklist, signed artefacts reference/governance.md, explanation/devsecops-supply-chain.md AI assistance Local-model propose \u2192 rank \u2192 validate loop how-to/ai-assisted-refactors.md, explanation/ai-orchestration.md","title":"Key capabilities at a glance"},{"location":"explanation/executive-summary/#executive-visuals","text":"flowchart LR subgraph Contract Governance A[Project Contract<br/>Versioned Standards] B[Evidence & Rationale] end subgraph Automation Engine C[Universal IR<br/>Tree-sitter \u2022 CodeQL \u2022 Semgrep] D[Deterministic Codemods Safety Gate] end subgraph Business Outcomes E[Faster Reviews<br/>Policy Compliance] F[Audit-Ready Releases<br/>Provable SBOM & Attestation] G[Developer Productivity<br/>Less Manual Rework] end A --> C --> D --> E B --> C D --> F D --> G timeline title Emperator Adoption Timeline phase One: Foundation month 1 : Check-only mode in CI month 1 : Tutorial pilot repo onboarded phase Two: Automation month 2 : Formatting + low-risk codemods auto-applied month 2 : SBOM + provenance artefacts published phase Three: Expansion month 3 : Strict gating on critical rules month 3 : AI-assisted migrations enabled with validation loop phase Four: Governance month 4 : Waiver reviews automated month 4 : Executive dashboards and evidence packs delivered Adopt Emperator Gradually Start in check-only mode: Run emperor check --format sarif in CI to surface gaps without blocking merges. Pilot auto-fixes on low-risk rules: Enable formatting and trivial codemods in a staging repo; confirm tests stay green. Expand coverage iteratively: Promote rules to --strict once teams trust the output, then introduce higher-tier codemods with safety gating. Instrument metrics: Track violations resolved, runtime, and waiver trends to prove ROI and identify where to invest next.","title":"Executive visuals"},{"location":"explanation/executive-summary/#recommended-rollout-narrative","text":"Assess the baseline: Use the tutorial to index an existing project, reviewing the initial findings report with architecture and security leads. Define success metrics: Agree on target reduction in manual review comments, critical security findings, or dependency drift. Automate the pipeline: Integrate the CI template, generate SBOM/provenance artefacts, and ensure stakeholders can access the reports. Enable AI with guardrails: Once deterministic automation is stable, opt in to AI-assisted refactors for complex migrations, keeping validation in place. Operationalize governance: Schedule recurring waiver reviews, sign releases, and store evidence packs for audits\u2014completing the contract-as-code loop. Use this summary to brief executives, security stakeholders, or new team members before diving into the detailed sections of the technical brief.","title":"Recommended rollout narrative"},{"location":"explanation/implementation-roadmap/","text":"Implementation Roadmap \u00b6 The roadmap provides a pragmatic sequence for delivering Emperator, starting with a focused Python slice and expanding once the core pipeline proves reliable. Phase 1: Python-focused slice (6\u20138 weeks) \u00b6 Contract parsing: Support CUE-based naming and layering rules, a small Rego policy for security, and an OpenAPI snippet to drive scaffold generation. IR construction: Integrate Tree-sitter for Python, run targeted Semgrep rules, and generate a CodeQL database for selected semantic checks. Checks: Detect naming convention violations, forbidden imports across layers, and insecure shell execution. Fixes: Auto-rename identifiers via LibCST, run Ruff/Black formatters, and scaffold missing handlers implied by the contract. Safety: Re-run checks after fixes and execute at least one property-based test (e.g., DTO round-trip) to show the safety envelope in action. CLI experience: Deliver emperor apply with diff output, summaries, and exit codes suitable for pre-commit and CI. Demo project: Curate a sample repo exhibiting each violation type to showcase before/after results. Phase 2: Developer feedback loop \u00b6 Pilot the tool with real teams to gather usability data, measure runtime, and identify noisy rules. Harden pre-commit and CI integrations, including SARIF uploads and provenance artefact capture. Expand documentation and tutorials based on pilot feedback, especially around waiver workflows and troubleshooting. Phase 3: Polyglot expansion \u00b6 Add Java/OpenRewrite support, then JavaScript/TypeScript with ESLint or TypeScript AST integrations. Broaden Semgrep and CodeQL rule packs, including organization-specific security checks. Enhance LSP features for richer in-editor diagnostics and quick fixes. Phase 4: AI augmentation \u00b6 Introduce optional local LLM assistance for complex migrations following the propose \u2192 rank \u2192 validate loop. Measure success criteria (e.g., proportion of issues resolved automatically, review acceptance rate) and iterate prompts. Package successful AI-assisted transforms as deterministic codemods to reduce future reliance on models. Phase 5: Reporting and governance \u00b6 Deliver dashboards or HTML summaries highlighting contract compliance trends, SBOM status, and waiver aging. Integrate with risk management systems to align exemptions and mitigation plans with governance cadences. Formalize release engineering workflows with signed attestations and comprehensive evidence packs for audits. This phased approach keeps risk low, builds trust through incremental wins, and ensures each capability ships with the necessary documentation, automation, and validation.","title":"Implementation Roadmap"},{"location":"explanation/implementation-roadmap/#implementation-roadmap","text":"The roadmap provides a pragmatic sequence for delivering Emperator, starting with a focused Python slice and expanding once the core pipeline proves reliable.","title":"Implementation Roadmap"},{"location":"explanation/implementation-roadmap/#phase-1-python-focused-slice-68-weeks","text":"Contract parsing: Support CUE-based naming and layering rules, a small Rego policy for security, and an OpenAPI snippet to drive scaffold generation. IR construction: Integrate Tree-sitter for Python, run targeted Semgrep rules, and generate a CodeQL database for selected semantic checks. Checks: Detect naming convention violations, forbidden imports across layers, and insecure shell execution. Fixes: Auto-rename identifiers via LibCST, run Ruff/Black formatters, and scaffold missing handlers implied by the contract. Safety: Re-run checks after fixes and execute at least one property-based test (e.g., DTO round-trip) to show the safety envelope in action. CLI experience: Deliver emperor apply with diff output, summaries, and exit codes suitable for pre-commit and CI. Demo project: Curate a sample repo exhibiting each violation type to showcase before/after results.","title":"Phase 1: Python-focused slice (6\u20138 weeks)"},{"location":"explanation/implementation-roadmap/#phase-2-rollout","text":"Pilot the tool with real teams to gather usability data, measure runtime, and identify noisy rules. Harden pre-commit and CI integrations, including SARIF uploads and provenance artefact capture. Expand documentation and tutorials based on pilot feedback, especially around waiver workflows and troubleshooting.","title":"Phase 2: Developer feedback loop"},{"location":"explanation/implementation-roadmap/#phase-3-organization-wide-enforcement","text":"Add Java/OpenRewrite support, then JavaScript/TypeScript with ESLint or TypeScript AST integrations. Broaden Semgrep and CodeQL rule packs, including organization-specific security checks. Enhance LSP features for richer in-editor diagnostics and quick fixes.","title":"Phase 3: Polyglot expansion"},{"location":"explanation/implementation-roadmap/#phase-4-ai-augmentation","text":"Introduce optional local LLM assistance for complex migrations following the propose \u2192 rank \u2192 validate loop. Measure success criteria (e.g., proportion of issues resolved automatically, review acceptance rate) and iterate prompts. Package successful AI-assisted transforms as deterministic codemods to reduce future reliance on models.","title":"Phase 4: AI augmentation"},{"location":"explanation/implementation-roadmap/#phase-5-reporting-and-governance","text":"Deliver dashboards or HTML summaries highlighting contract compliance trends, SBOM status, and waiver aging. Integrate with risk management systems to align exemptions and mitigation plans with governance cadences. Formalize release engineering workflows with signed attestations and comprehensive evidence packs for audits. This phased approach keeps risk low, builds trust through incremental wins, and ensures each capability ships with the necessary documentation, automation, and validation.","title":"Phase 5: Reporting and governance"},{"location":"explanation/security-safety/","text":"Security Engineering and Safety Envelope \u00b6 Emperator hardens codebases by combining defense-in-depth analysis with conservative automation safeguards. Comprehensive vulnerability coverage \u00b6 Runs curated Semgrep and CodeQL query packs aligned with OWASP Top 10 and high-priority CWE categories. Uses taint tracking to detect untrusted data flows from external inputs to dangerous sinks (e.g., os.system , raw SQL execution). Integrates secret scanning patterns to block credentials, tokens, and keys from entering source control. Safety tiers for automation \u00b6 Classifies rules into tiers (formatting, low, medium, high) so only low-risk fixes auto-apply; higher tiers surface reviewable diffs. Re-runs static analysis and optional unit/property tests after every automated change, rolling back any patch that fails validation. Enforces idempotence: codemods are expected to produce no further changes when applied twice, preventing oscillating diffs. Property-based and regression testing \u00b6 Generates Hypothesis-based round-trip tests for designated data structures (e.g., DTO serialization) to confirm behaviour remains intact after refactors. Supports codemod regression suites ( emperor codemod verify ) to guarantee recipes remain safe as contracts evolve. Exemption hygiene \u00b6 Requires waiver annotations to include justification, owner, and expiry; pipeline flags expire soon or missing rationale. Produces waiver dashboards so security leads can track accepted risk and schedule remediation work. Threat-aware operations \u00b6 Runs entirely offline by default, avoiding data exfiltration risks and supporting air-gapped environments. Executes optional dynamic checks inside hardened temporary sandboxes to minimise exposure to adversarial code. Treats the contract as untrusted input, relying on vetted parsers for OpenAPI, CUE, and Rego to prevent injection attacks against the toolchain. Container hardening \u00b6 Provide hardened base images for developer containers and CI runners with pinned versions of formatters, linters, and Emperator binaries. Scan container layers with hadolint and follow the Toolchain Matrix to ensure Dockerfiles invoke vetted linters. Sign container images and publish SBOMs so downstream teams inherit the same provenance guarantees enforced upstream. By combining rigorous detection with a \u201cfirst, do no harm\u201d automation policy, Emperator raises the security baseline without eroding trust in automated refactors.","title":"Security and Safety Envelope"},{"location":"explanation/security-safety/#security-engineering-and-safety-envelope","text":"Emperator hardens codebases by combining defense-in-depth analysis with conservative automation safeguards.","title":"Security Engineering and Safety Envelope"},{"location":"explanation/security-safety/#comprehensive-vulnerability-coverage","text":"Runs curated Semgrep and CodeQL query packs aligned with OWASP Top 10 and high-priority CWE categories. Uses taint tracking to detect untrusted data flows from external inputs to dangerous sinks (e.g., os.system , raw SQL execution). Integrates secret scanning patterns to block credentials, tokens, and keys from entering source control.","title":"Comprehensive vulnerability coverage"},{"location":"explanation/security-safety/#static-analysis-tiers","text":"Classifies rules into tiers (formatting, low, medium, high) so only low-risk fixes auto-apply; higher tiers surface reviewable diffs. Re-runs static analysis and optional unit/property tests after every automated change, rolling back any patch that fails validation. Enforces idempotence: codemods are expected to produce no further changes when applied twice, preventing oscillating diffs.","title":"Safety tiers for automation"},{"location":"explanation/security-safety/#property-based-and-regression-testing","text":"Generates Hypothesis-based round-trip tests for designated data structures (e.g., DTO serialization) to confirm behaviour remains intact after refactors. Supports codemod regression suites ( emperor codemod verify ) to guarantee recipes remain safe as contracts evolve.","title":"Property-based and regression testing"},{"location":"explanation/security-safety/#exemption-hygiene","text":"Requires waiver annotations to include justification, owner, and expiry; pipeline flags expire soon or missing rationale. Produces waiver dashboards so security leads can track accepted risk and schedule remediation work.","title":"Exemption hygiene"},{"location":"explanation/security-safety/#threat-aware-operations","text":"Runs entirely offline by default, avoiding data exfiltration risks and supporting air-gapped environments. Executes optional dynamic checks inside hardened temporary sandboxes to minimise exposure to adversarial code. Treats the contract as untrusted input, relying on vetted parsers for OpenAPI, CUE, and Rego to prevent injection attacks against the toolchain.","title":"Threat-aware operations"},{"location":"explanation/security-safety/#container-hardening","text":"Provide hardened base images for developer containers and CI runners with pinned versions of formatters, linters, and Emperator binaries. Scan container layers with hadolint and follow the Toolchain Matrix to ensure Dockerfiles invoke vetted linters. Sign container images and publish SBOMs so downstream teams inherit the same provenance guarantees enforced upstream. By combining rigorous detection with a \u201cfirst, do no harm\u201d automation policy, Emperator raises the security baseline without eroding trust in automated refactors.","title":"Container hardening"},{"location":"explanation/system-architecture/","text":"System Architecture Deep Dive \u00b6 Emperator\u2019s architecture turns a versioned Project Contract into actionable checks, deterministic fixes, and scaffolded code. The system can be reasoned about in three layers that align with the Contract\u2192IR\u2192Action pipeline illustrated below. flowchart LR subgraph Contract Layer A[Contract Assets<br/>(OpenAPI \u2022 CUE \u2022 Rego \u2022 Templates)] end subgraph IR & Analysis Layer B[Universal Code IR<br/>\u2013 Tree-sitter CST<br/>\u2013 CodeQL semantic DB<br/>\u2013 Semgrep pattern index] end subgraph Execution Layer C1[Check Engines] C2[Fix Engines] C3[Scaffold & Format] end A --> B --> C1 C1 -->|Violations?| D{Safety Gate} D -->|Auto-fixable| C2 --> C3 --> E[Proposed or Applied Changes] D -->|Review needed| E E --> F[Re-check & Optional Tests] F -->|Pass| G[\u2705 Standards satisfied] F -->|Fail| H[Rollback & Report] Layered overview \u00b6 Contract layer: Stores declarative standards in existing open formats (OpenAPI for interface contracts, CUE for naming/config constraints, OPA Rego for policies, plus codemod templates). Contracts are version-controlled and treated as first-class artefacts so standards evolve without drifting from code. IR & analysis layer: Builds a polyglot intermediate representation by combining Tree-sitter concrete syntax trees, CodeQL semantic databases, and Semgrep\u2019s pattern index. The result is a unified graph that supports fast local checks and deep cross-language reasoning. Execution layer: Compiles contract rules into checks, fixes, scaffolds, and formatter runs. Each action is orchestrated through the Safety Gate, which classifies findings by severity and determines whether Emperator can auto-remediate or should defer to a developer. This structure maps cleanly to a C4 view: the CLI/LSP service acts as the primary container, backed by modular components (contract loader, IR builder, check coordinator, codemod runner, formatter and report generator) that communicate via typed rule and finding objects. Contract layer responsibilities \u00b6 Standards as code: Contracts leverage proven DSLs so the same definitions can be validated independently or shared across systems. OpenAPI specs drive handler scaffolding, CUE encodes structural constraints, and Rego expresses higher-order policies such as dependency allowlists or security posture requirements. Versioning and provenance: Every rule change is traceable. Emperator stamps applied fixes with the contract revision and logs the reasoning, enabling audits and staged rollouts (e.g., warn-only before enforcing breaking rules). Evidence grading: Rules can reference external standards (OWASP, MISRA, internal policies) with citations so developers understand the \u201cwhy\u201d behind each enforcement. Universal IR construction \u00b6 Tree-sitter parsing: Provides incremental, lossless CSTs for dozens of languages. Emperator uses them to trigger near real-time diagnostics in editor integrations and to feed higher-level analyses without reparsing entire files. CodeQL enrichment: Generates semantic databases for supported languages, exposing control-flow and data-flow relationships. Emperator ships with curated query packs that enforce architecture boundaries, detect security issues, and surface dependency violations. Semgrep pattern catalog: Converts contract snippets into multi-language patterns for quick, diff-friendly scans. Community security rules and custom project checks run alongside the contract-derived rules. Incremental updates: A background daemon watches source changes, re-running only the relevant analyses. This keeps feedback loops short while supporting large repositories. Action engines and safety envelope \u00b6 Check engines: Run Semgrep rules, CodeQL queries, and contract validators. Findings are tagged with severity, evidence confidence, and auto-fix eligibility. High-noise detections are triaged for manual review. Fix engines: Apply deterministic codemods (LibCST, OpenRewrite, language-specific refactorers) for rules classified as safe. Complex migrations can be proposed as diffs rather than applied automatically. Scaffold & generate: Templates in contract/generators/ create handlers, tests, or migration stubs based on contract deltas (e.g., new OpenAPI endpoints). Generated code is re-checked before acceptance. Formatters: Invoke battle-tested formatters such as Ruff, Black, Prettier, gofmt, or clang-format to ensure minimal diffs that match team conventions (see the Toolchain Matrix for language-specific pairings). Safety gate: Categorizes each change into tiers (formatting, low-risk refactor, complex migration) and enforces validation. After a fix, Emperator re-runs the relevant checks and optional property-based tests before marking the issue resolved. Failures result in automatic rollback and a detailed report. Extensibility and performance \u00b6 Plugin interfaces: New languages integrate by implementing parser adapters, analyzer hooks, and codemod providers. Policy plug-ins can introduce specialized analyzers (e.g., MISRA checkers) without altering the core orchestrator. Performance budgets: Emperator differentiates between fast interactive checks and exhaustive CI runs. Users can opt into deeper analyses (full CodeQL packs, fuzz tests) in pipelines while keeping pre-commit execution under a few seconds. Offline operation: All components run locally, ensuring suitability for air-gapped environments. Optional AI assistance uses on-prem models only (see the AI-assisted how-to guide for details). With this architecture, Emperator ensures contracts remain executable, analyses stay coherent across languages, and automated changes land safely under rigorous validation. Related references \u00b6 Map contract rules to analyzers in the Toolchain Matrix . Follow the rollout stages in the Implementation Roadmap . Align governance levers with the Governance and Compliance reference .","title":"System Architecture Deep Dive"},{"location":"explanation/system-architecture/#system-architecture-deep-dive","text":"Emperator\u2019s architecture turns a versioned Project Contract into actionable checks, deterministic fixes, and scaffolded code. The system can be reasoned about in three layers that align with the Contract\u2192IR\u2192Action pipeline illustrated below. flowchart LR subgraph Contract Layer A[Contract Assets<br/>(OpenAPI \u2022 CUE \u2022 Rego \u2022 Templates)] end subgraph IR & Analysis Layer B[Universal Code IR<br/>\u2013 Tree-sitter CST<br/>\u2013 CodeQL semantic DB<br/>\u2013 Semgrep pattern index] end subgraph Execution Layer C1[Check Engines] C2[Fix Engines] C3[Scaffold & Format] end A --> B --> C1 C1 -->|Violations?| D{Safety Gate} D -->|Auto-fixable| C2 --> C3 --> E[Proposed or Applied Changes] D -->|Review needed| E E --> F[Re-check & Optional Tests] F -->|Pass| G[\u2705 Standards satisfied] F -->|Fail| H[Rollback & Report]","title":"System Architecture Deep Dive"},{"location":"explanation/system-architecture/#layered-overview","text":"Contract layer: Stores declarative standards in existing open formats (OpenAPI for interface contracts, CUE for naming/config constraints, OPA Rego for policies, plus codemod templates). Contracts are version-controlled and treated as first-class artefacts so standards evolve without drifting from code. IR & analysis layer: Builds a polyglot intermediate representation by combining Tree-sitter concrete syntax trees, CodeQL semantic databases, and Semgrep\u2019s pattern index. The result is a unified graph that supports fast local checks and deep cross-language reasoning. Execution layer: Compiles contract rules into checks, fixes, scaffolds, and formatter runs. Each action is orchestrated through the Safety Gate, which classifies findings by severity and determines whether Emperator can auto-remediate or should defer to a developer. This structure maps cleanly to a C4 view: the CLI/LSP service acts as the primary container, backed by modular components (contract loader, IR builder, check coordinator, codemod runner, formatter and report generator) that communicate via typed rule and finding objects.","title":"Layered overview"},{"location":"explanation/system-architecture/#contract-layer-responsibilities","text":"Standards as code: Contracts leverage proven DSLs so the same definitions can be validated independently or shared across systems. OpenAPI specs drive handler scaffolding, CUE encodes structural constraints, and Rego expresses higher-order policies such as dependency allowlists or security posture requirements. Versioning and provenance: Every rule change is traceable. Emperator stamps applied fixes with the contract revision and logs the reasoning, enabling audits and staged rollouts (e.g., warn-only before enforcing breaking rules). Evidence grading: Rules can reference external standards (OWASP, MISRA, internal policies) with citations so developers understand the \u201cwhy\u201d behind each enforcement.","title":"Contract layer responsibilities"},{"location":"explanation/system-architecture/#universal-ir-construction","text":"Tree-sitter parsing: Provides incremental, lossless CSTs for dozens of languages. Emperator uses them to trigger near real-time diagnostics in editor integrations and to feed higher-level analyses without reparsing entire files. CodeQL enrichment: Generates semantic databases for supported languages, exposing control-flow and data-flow relationships. Emperator ships with curated query packs that enforce architecture boundaries, detect security issues, and surface dependency violations. Semgrep pattern catalog: Converts contract snippets into multi-language patterns for quick, diff-friendly scans. Community security rules and custom project checks run alongside the contract-derived rules. Incremental updates: A background daemon watches source changes, re-running only the relevant analyses. This keeps feedback loops short while supporting large repositories.","title":"Universal IR construction"},{"location":"explanation/system-architecture/#action-engines-and-safety-envelope","text":"Check engines: Run Semgrep rules, CodeQL queries, and contract validators. Findings are tagged with severity, evidence confidence, and auto-fix eligibility. High-noise detections are triaged for manual review. Fix engines: Apply deterministic codemods (LibCST, OpenRewrite, language-specific refactorers) for rules classified as safe. Complex migrations can be proposed as diffs rather than applied automatically. Scaffold & generate: Templates in contract/generators/ create handlers, tests, or migration stubs based on contract deltas (e.g., new OpenAPI endpoints). Generated code is re-checked before acceptance. Formatters: Invoke battle-tested formatters such as Ruff, Black, Prettier, gofmt, or clang-format to ensure minimal diffs that match team conventions (see the Toolchain Matrix for language-specific pairings). Safety gate: Categorizes each change into tiers (formatting, low-risk refactor, complex migration) and enforces validation. After a fix, Emperator re-runs the relevant checks and optional property-based tests before marking the issue resolved. Failures result in automatic rollback and a detailed report.","title":"Action engines and safety envelope"},{"location":"explanation/system-architecture/#extensibility-and-performance","text":"Plugin interfaces: New languages integrate by implementing parser adapters, analyzer hooks, and codemod providers. Policy plug-ins can introduce specialized analyzers (e.g., MISRA checkers) without altering the core orchestrator. Performance budgets: Emperator differentiates between fast interactive checks and exhaustive CI runs. Users can opt into deeper analyses (full CodeQL packs, fuzz tests) in pipelines while keeping pre-commit execution under a few seconds. Offline operation: All components run locally, ensuring suitability for air-gapped environments. Optional AI assistance uses on-prem models only (see the AI-assisted how-to guide for details). With this architecture, Emperator ensures contracts remain executable, analyses stay coherent across languages, and automated changes land safely under rigorous validation.","title":"Extensibility and performance"},{"location":"explanation/system-architecture/#related-references","text":"Map contract rules to analyzers in the Toolchain Matrix . Follow the rollout stages in the Implementation Roadmap . Align governance levers with the Governance and Compliance reference .","title":"Related references"},{"location":"how-to/ai-assisted-refactors/","text":"Using AI-Assisted Refactors Safely \u00b6 Emperor\u2019s deterministic codemods cover common rules, but some refactors benefit from context-aware suggestions. This guide explains how to enable local LLM support and keep every AI-generated change within Emperator\u2019s safety envelope. 1. Enable local models \u00b6 Install an open-source code-capable model (e.g., Code Llama, StarCoder, Phi-3) that fits your security requirements. Keep weights on-prem to avoid leaking proprietary code. Configure Emperator\u2019s AI bridge via emperor ai init --model path/to/model.gguf --max-tokens 1024 . This stores model metadata in .emperor/config.yaml . Set EMPERATOR_AI_ENABLED=1 in your environment to opt in. .emperor/config.yaml ai : provider : local model_path : /models/code-llama-13b.gguf context_window : 32768 temperature : 0.15 stop_sequences : - \"```\" - \"# end\" 2. Follow the propose \u2192 rank \u2192 validate loop \u00b6 flowchart LR A[Static analysis finding] --> B[LLM prompt builder] B --> C[Generate N candidate patches] C --> D[Ranker (contract diff heuristics)] D --> E[Safety gate] E -->|passes checks| F[Apply patch + log provenance] E -->|fails| G[Discard + surface manual TODO] The loop guarantees that AI assistance never bypasses Emperator\u2019s core validation: Propose: Emperator crafts a prompt with the rule description, relevant code slice, and contract snippets. It requests multiple candidates to improve diversity. Rank: Candidates are evaluated using contract-aware heuristics (diff size, naming compliance) and quick static checks. Lower-ranked suggestions are discarded early. Validate: The remaining candidate is applied in a scratch workspace, then Emperator re-runs static analysis and optional property-based tests. Only if everything passes does the change graduate to a formal suggestion. 3. Craft effective prompts \u00b6 Reference authoritative docs in the prompt payload (e.g., link to new API contract, cite policy rationale). Models perform better when given explicit constraints. Provide before/after code patterns for deterministic sections, keeping the AI focused on the gap you need filled. Include acceptance tests or assertions when possible so the validation stage can execute them immediately. Example prompt block stored in docs/includes/copilot-prompts.md : You are Emperator\u2019s refactoring planner. Transform the provided code so it complies with the contract rule: {{ rule.id }} \u2014 {{ rule.description }}. Constraints: - Maintain public signatures. - Preserve documented side effects. - Prefer codemodable patterns (LibCST/OpenRewrite friendly). Return unified diff only. 4. Gate AI suggestions by safety tier \u00b6 Map each contract rule to a safety tier ( formatting , low , medium , high ). Allow automatic AI fixes only for formatting and low ; surface medium/high as reviewable diffs. Require human approval when AI changes touch security-critical modules, persistence layers, or public API contracts. Log provenance (model version, prompt hash) with emperor explain --last so reviewers can inspect the AI context. 5. Test before trusting \u00b6 Run emperor test --scope touched-files after each accepted AI patch. Emperator can synthesize property-based tests for marked functions, providing additional assurance. For migrations, pair AI-generated diffs with codemod regression tests to ensure idempotence ( emperor codemod verify path/to/recipe.py ). Lint-aware fixes \u00b6 Keep the Toolchain Matrix handy so AI suggestions never fight formatter output. Apply formatters ( ruff format , prettier --write , gofmt ) immediately after accepting an AI diff to normalize style before review. Prefer codemod-plus-formatter combinations for deterministic cleanups; Emperator can chain Ruff/Prettier after AI changes to minimize noise in pull requests. When a team mandates a specific formatter (e.g., Black), configure Emperator\u2019s safety tiers so AI fixes stop short of reformats and leave the existing formatter to resolve layout. 6. Maintain feedback loops \u00b6 Capture rejected suggestions to fine-tune prompts or adjust model parameters (e.g., reduce temperature to limit creative deviations). Periodically retrain or swap models as new open releases improve code quality metrics. Update the Copilot prompt include with new rule exemplars so human copilots stay aligned with the latest contract expectations. By treating AI output as a proposal that must earn its place through the same stringent checks as manual code, you gain the productivity benefits of context-aware refactors without compromising safety.","title":"Use AI-Assisted Refactors Safely"},{"location":"how-to/ai-assisted-refactors/#using-ai-assisted-refactors-safely","text":"Emperor\u2019s deterministic codemods cover common rules, but some refactors benefit from context-aware suggestions. This guide explains how to enable local LLM support and keep every AI-generated change within Emperator\u2019s safety envelope.","title":"Using AI-Assisted Refactors Safely"},{"location":"how-to/ai-assisted-refactors/#1-enable-local-models","text":"Install an open-source code-capable model (e.g., Code Llama, StarCoder, Phi-3) that fits your security requirements. Keep weights on-prem to avoid leaking proprietary code. Configure Emperator\u2019s AI bridge via emperor ai init --model path/to/model.gguf --max-tokens 1024 . This stores model metadata in .emperor/config.yaml . Set EMPERATOR_AI_ENABLED=1 in your environment to opt in. .emperor/config.yaml ai : provider : local model_path : /models/code-llama-13b.gguf context_window : 32768 temperature : 0.15 stop_sequences : - \"```\" - \"# end\"","title":"1. Enable local models"},{"location":"how-to/ai-assisted-refactors/#2-follow-the-propose-rank-validate-loop","text":"flowchart LR A[Static analysis finding] --> B[LLM prompt builder] B --> C[Generate N candidate patches] C --> D[Ranker (contract diff heuristics)] D --> E[Safety gate] E -->|passes checks| F[Apply patch + log provenance] E -->|fails| G[Discard + surface manual TODO] The loop guarantees that AI assistance never bypasses Emperator\u2019s core validation: Propose: Emperator crafts a prompt with the rule description, relevant code slice, and contract snippets. It requests multiple candidates to improve diversity. Rank: Candidates are evaluated using contract-aware heuristics (diff size, naming compliance) and quick static checks. Lower-ranked suggestions are discarded early. Validate: The remaining candidate is applied in a scratch workspace, then Emperator re-runs static analysis and optional property-based tests. Only if everything passes does the change graduate to a formal suggestion.","title":"2. Follow the propose \u2192 rank \u2192 validate loop"},{"location":"how-to/ai-assisted-refactors/#3-craft-effective-prompts","text":"Reference authoritative docs in the prompt payload (e.g., link to new API contract, cite policy rationale). Models perform better when given explicit constraints. Provide before/after code patterns for deterministic sections, keeping the AI focused on the gap you need filled. Include acceptance tests or assertions when possible so the validation stage can execute them immediately. Example prompt block stored in docs/includes/copilot-prompts.md : You are Emperator\u2019s refactoring planner. Transform the provided code so it complies with the contract rule: {{ rule.id }} \u2014 {{ rule.description }}. Constraints: - Maintain public signatures. - Preserve documented side effects. - Prefer codemodable patterns (LibCST/OpenRewrite friendly). Return unified diff only.","title":"3. Craft effective prompts"},{"location":"how-to/ai-assisted-refactors/#4-gate-ai-suggestions-by-safety-tier","text":"Map each contract rule to a safety tier ( formatting , low , medium , high ). Allow automatic AI fixes only for formatting and low ; surface medium/high as reviewable diffs. Require human approval when AI changes touch security-critical modules, persistence layers, or public API contracts. Log provenance (model version, prompt hash) with emperor explain --last so reviewers can inspect the AI context.","title":"4. Gate AI suggestions by safety tier"},{"location":"how-to/ai-assisted-refactors/#5-test-before-trusting","text":"Run emperor test --scope touched-files after each accepted AI patch. Emperator can synthesize property-based tests for marked functions, providing additional assurance. For migrations, pair AI-generated diffs with codemod regression tests to ensure idempotence ( emperor codemod verify path/to/recipe.py ).","title":"5. Test before trusting"},{"location":"how-to/ai-assisted-refactors/#lint-aware-fixes","text":"Keep the Toolchain Matrix handy so AI suggestions never fight formatter output. Apply formatters ( ruff format , prettier --write , gofmt ) immediately after accepting an AI diff to normalize style before review. Prefer codemod-plus-formatter combinations for deterministic cleanups; Emperator can chain Ruff/Prettier after AI changes to minimize noise in pull requests. When a team mandates a specific formatter (e.g., Black), configure Emperator\u2019s safety tiers so AI fixes stop short of reformats and leave the existing formatter to resolve layout.","title":"Lint-aware fixes"},{"location":"how-to/ai-assisted-refactors/#6-maintain-feedback-loops","text":"Capture rejected suggestions to fine-tune prompts or adjust model parameters (e.g., reduce temperature to limit creative deviations). Periodically retrain or swap models as new open releases improve code quality metrics. Update the Copilot prompt include with new rule exemplars so human copilots stay aligned with the latest contract expectations. By treating AI output as a proposal that must earn its place through the same stringent checks as manual code, you gain the productivity benefits of context-aware refactors without compromising safety.","title":"6. Maintain feedback loops"},{"location":"how-to/author-contract/","text":"Authoring and Evolving the Project Contract \u00b6 The Project Contract is the single source of truth for Emperator\u2019s standards. This guide shows how to structure the contract repository, encode rules with open standards, validate changes, and stage rollouts safely. 1. Scaffold the contract directory \u00b6 Place the contract in a top-level contract/ folder so Emperator can discover it automatically. contract/ \u251c\u2500\u2500 api/ # OpenAPI or GraphQL interface specs \u251c\u2500\u2500 conventions.cue # CUE constraints for naming, layout, metadata \u251c\u2500\u2500 policy/ # OPA Rego policies for security and governance \u251c\u2500\u2500 generators/ # Templates and codemod recipes \u2514\u2500\u2500 README.md # Change log and review checklist Best practices: Keep contract artefacts close to the code they govern. Co-locating the contract eliminates drift between documentation and implementation. Document intent in README.md ; include reviewer checklists and links to upstream standards (OWASP, SLSA, internal policies). Group generators by language or domain ( generators/python/ , generators/devsecops/ ) to simplify maintenance. 2. Define structural conventions with CUE \u00b6 CUE expresses schema-like constraints succinctly and supports rich validation. contract/conventions.cue package contract controllers: { files: [...string] & =~\"^[a-z0-9_]+\\.py$\" allowImports: [...string] | *[\"services\", \"logging\"] } formatting: { python: { formatter: \"ruff\" lineLength: 100 } } The regex ensures controller filenames stay in snake_case . The allowImports array drives layering rules (hooked into Semgrep and CodeQL queries). Formatting settings flow into Emperator\u2019s formatter adapters so generated code matches expectations. Validate CUE edits with cue vet or cue export during contract review. 3. Capture policies with OPA Rego \u00b6 Use Rego to codify security and governance rules that span multiple analyses. contract/policy/rules.rego package contract . security deny [ msg ] { input . findings [ _ ]. rule == \"SecretDetection\" msg := \"Hardcoded secret detected\" } warn [ msg ] { some finding finding := input . findings [ _ ] finding . rule == \"LayeringPolicy\" finding . severity == \"medium\" msg := sprintf ( \"Layering violation (%s) requires review\" , [ finding . location ]) } Feed Emperator\u2019s findings JSON into OPA to aggregate, suppress, or escalate alerts. Use deny for blocking issues, warn for advisory or transitional policies. Keep policies composable; break complex rules into helper modules and import them. Evaluate policies locally with opa eval -i findings.json -d contract/policy 'data.contract' . 4. Model API surfaces with OpenAPI or GraphQL \u00b6 Interface specifications enable Emperator to scaffold handlers, tests, and clients consistently. contract/api/openapi.yaml openapi : 3.1.0 info : title : Emperator Reference Contract version : 1.2.0 paths : /healthz : get : operationId : getHealth responses : '200' : description : OK Align operation IDs with code generation templates in contract/generators/ . Use shared schemas to enforce DTO structure. Emperator compares schemas against model code using the IR. Treat OpenAPI version bumps as contract releases; annotate the change log with migration guidance. 5. Create deterministic codemod recipes \u00b6 Write LibCST-based Python codemods or OpenRewrite recipes and store them under contract/generators/ . Annotate each recipe with a safety tier ( format , low , medium , high ) so the Safety Gate knows whether to auto-apply or require review. Include unit tests for codemods where practical (e.g., tests/generators/test_logging_migration.py ). 6. Review and version the contract \u00b6 Follow a lightweight but disciplined review loop: flowchart LR P[Draft rule change] --> R[Peer review (code + policy experts)] R --> V[Validate locally (cue vet, opa eval, emperor dry-run)] V --> D[Decide release tier (warn-only or enforce)] D --> T[Tag contract version] T --> B[Broadcast change (docs, release notes, Copilot prompts)] Warn-only rollouts: Introduce new rules in advisory mode first ( severity: info or auto_apply: false ) and flip to blocking once noise is under control. Version tags: Use semantic versioning ( contract@1.3.0 ). Emperator logs the active version with every fix, giving auditors traceability. Broadcast: Update docs/reference/contract-spec.md and Copilot prompt packs so automated assistants surface the new expectations. 7. Manage exemptions deliberately \u00b6 Allow explicit overrides via inline comments such as # emperator:ignore LayeringPolicy -- justification . Reject exemptions without a justification string. Track approved exemptions in a dedicated file ( contract/exemptions.yaml ) including owner, expiry, and mitigation plan. Periodically audit and retire exemptions; Emperator\u2019s governance reports list outstanding waivers. 8. Automate contract validation in CI \u00b6 Add a job that runs emperor check --strict --no-fix against the latest contract to ensure it compiles and that generated rules are lint-free. Fail fast if cue fmt or opa fmt detect formatting issues\u2014consistency keeps diffs minimal. Publish generated documentation (mkdocs, SARIF summaries) as build artefacts for reviewers. With these practices the Project Contract becomes a living, executable specification that guides every code change while remaining auditable and adaptable.","title":"Author the Project Contract"},{"location":"how-to/author-contract/#authoring-and-evolving-the-project-contract","text":"The Project Contract is the single source of truth for Emperator\u2019s standards. This guide shows how to structure the contract repository, encode rules with open standards, validate changes, and stage rollouts safely.","title":"Authoring and Evolving the Project Contract"},{"location":"how-to/author-contract/#1-scaffold-the-contract-directory","text":"Place the contract in a top-level contract/ folder so Emperator can discover it automatically. contract/ \u251c\u2500\u2500 api/ # OpenAPI or GraphQL interface specs \u251c\u2500\u2500 conventions.cue # CUE constraints for naming, layout, metadata \u251c\u2500\u2500 policy/ # OPA Rego policies for security and governance \u251c\u2500\u2500 generators/ # Templates and codemod recipes \u2514\u2500\u2500 README.md # Change log and review checklist Best practices: Keep contract artefacts close to the code they govern. Co-locating the contract eliminates drift between documentation and implementation. Document intent in README.md ; include reviewer checklists and links to upstream standards (OWASP, SLSA, internal policies). Group generators by language or domain ( generators/python/ , generators/devsecops/ ) to simplify maintenance.","title":"1. Scaffold the contract directory"},{"location":"how-to/author-contract/#2-define-structural-conventions-with-cue","text":"CUE expresses schema-like constraints succinctly and supports rich validation. contract/conventions.cue package contract controllers: { files: [...string] & =~\"^[a-z0-9_]+\\.py$\" allowImports: [...string] | *[\"services\", \"logging\"] } formatting: { python: { formatter: \"ruff\" lineLength: 100 } } The regex ensures controller filenames stay in snake_case . The allowImports array drives layering rules (hooked into Semgrep and CodeQL queries). Formatting settings flow into Emperator\u2019s formatter adapters so generated code matches expectations. Validate CUE edits with cue vet or cue export during contract review.","title":"2. Define structural conventions with CUE"},{"location":"how-to/author-contract/#3-capture-policies-with-opa-rego","text":"Use Rego to codify security and governance rules that span multiple analyses. contract/policy/rules.rego package contract . security deny [ msg ] { input . findings [ _ ]. rule == \"SecretDetection\" msg := \"Hardcoded secret detected\" } warn [ msg ] { some finding finding := input . findings [ _ ] finding . rule == \"LayeringPolicy\" finding . severity == \"medium\" msg := sprintf ( \"Layering violation (%s) requires review\" , [ finding . location ]) } Feed Emperator\u2019s findings JSON into OPA to aggregate, suppress, or escalate alerts. Use deny for blocking issues, warn for advisory or transitional policies. Keep policies composable; break complex rules into helper modules and import them. Evaluate policies locally with opa eval -i findings.json -d contract/policy 'data.contract' .","title":"3. Capture policies with OPA Rego"},{"location":"how-to/author-contract/#4-model-api-surfaces-with-openapi-or-graphql","text":"Interface specifications enable Emperator to scaffold handlers, tests, and clients consistently. contract/api/openapi.yaml openapi : 3.1.0 info : title : Emperator Reference Contract version : 1.2.0 paths : /healthz : get : operationId : getHealth responses : '200' : description : OK Align operation IDs with code generation templates in contract/generators/ . Use shared schemas to enforce DTO structure. Emperator compares schemas against model code using the IR. Treat OpenAPI version bumps as contract releases; annotate the change log with migration guidance.","title":"4. Model API surfaces with OpenAPI or GraphQL"},{"location":"how-to/author-contract/#5-create-deterministic-codemod-recipes","text":"Write LibCST-based Python codemods or OpenRewrite recipes and store them under contract/generators/ . Annotate each recipe with a safety tier ( format , low , medium , high ) so the Safety Gate knows whether to auto-apply or require review. Include unit tests for codemods where practical (e.g., tests/generators/test_logging_migration.py ).","title":"5. Create deterministic codemod recipes"},{"location":"how-to/author-contract/#6-review-and-version-the-contract","text":"Follow a lightweight but disciplined review loop: flowchart LR P[Draft rule change] --> R[Peer review (code + policy experts)] R --> V[Validate locally (cue vet, opa eval, emperor dry-run)] V --> D[Decide release tier (warn-only or enforce)] D --> T[Tag contract version] T --> B[Broadcast change (docs, release notes, Copilot prompts)] Warn-only rollouts: Introduce new rules in advisory mode first ( severity: info or auto_apply: false ) and flip to blocking once noise is under control. Version tags: Use semantic versioning ( contract@1.3.0 ). Emperator logs the active version with every fix, giving auditors traceability. Broadcast: Update docs/reference/contract-spec.md and Copilot prompt packs so automated assistants surface the new expectations.","title":"6. Review and version the contract"},{"location":"how-to/author-contract/#7-manage-exemptions-deliberately","text":"Allow explicit overrides via inline comments such as # emperator:ignore LayeringPolicy -- justification . Reject exemptions without a justification string. Track approved exemptions in a dedicated file ( contract/exemptions.yaml ) including owner, expiry, and mitigation plan. Periodically audit and retire exemptions; Emperator\u2019s governance reports list outstanding waivers.","title":"7. Manage exemptions deliberately"},{"location":"how-to/author-contract/#8-automate-contract-validation-in-ci","text":"Add a job that runs emperor check --strict --no-fix against the latest contract to ensure it compiles and that generated rules are lint-free. Fail fast if cue fmt or opa fmt detect formatting issues\u2014consistency keeps diffs minimal. Publish generated documentation (mkdocs, SARIF summaries) as build artefacts for reviewers. With these practices the Project Contract becomes a living, executable specification that guides every code change while remaining auditable and adaptable.","title":"8. Automate contract validation in CI"},{"location":"how-to/ci-integration/","text":"Integrating Emperator with CI/CD Pipelines \u00b6 Emperator\u2019s contract enforcement is most effective when it runs consistently from developer workstations through CI, release packaging, and provenance attestation. This guide walks through recommended checkpoints and automation patterns. 1. Align local and CI workflows \u00b6 Install Emperator and supporting tools ( semgrep , codeql , formatters) in developer environments via pre-commit or language-specific toolchains. Add the pre-commit hook described in the tutorial so local commits run emperor apply --diff --color before code reaches the central repository. Encourage developers to run emperor check --strict --no-fix in feature branches to preview CI outcomes. 2. Stage checks in CI \u00b6 Use fast checks for pull requests and full checks for protected branches. flowchart TD A[Developer push] --> B[Pre-commit hook] B -->|passes| C[PR build] C --> D{Emperor mode} D -->|fast| E[semgrep diff \u2022 format validation] D -->|full| F[codeql pack \u2022 codemod dry-run \u2022 tests] E --> G[PR status checks] F --> G G --> H[Merge] H --> I[Release build] I --> J[Provenance & SBOM upload] Recommended modes: Fast (pull requests): emperor apply --diff --no-commit --fast with Semgrep diff scans, contract validation, and format checkers. Upload SARIF results for inline review comments. Full (mainline): emperor apply --strict plus emperor test --generators to run property-based tests or contract-driven scaffolds. Execute CodeQL query packs and produce SBOMs. 3. GitHub Actions template \u00b6 The workspace already includes .github/workflows/docs-ci.yml for MkDocs. Extend with a job dedicated to Emperator: name : Emperator Compliance on : pull_request : branches : [ main ] push : branches : [ main ] jobs : emperator : runs-on : ubuntu-latest steps : - uses : actions/checkout@v4 - name : Set up Python uses : actions/setup-python@v4 with : python-version : '3.11' - name : Install Emperator toolchain run : | python -m pip install --upgrade pip pip install emperator-cli semgrep curl -sSL https://github.com/github/codeql-action/releases/latest/download/codeql-bundle-linux64.tar.gz \\ | tar -xz -C \"$HOME\" echo \"CODEQL_HOME=$HOME/codeql\" >> \"$GITHUB_ENV\" - name : Run fast contract checks run : emperator apply --diff --no-commit --fast - name : Upload SARIF if : always() uses : github/codeql-action/upload-sarif@v2 with : sarif_file : reports/emperator.sarif Adaptations for other CI systems: GitLab CI: Install dependencies in a shared job and cache the Emperator virtual environment. Use artifacts:reports:sast to surface SARIF output in merge requests. Azure DevOps: Integrate with pipeline tasks to upload SARIF; gate deployments by adding a quality criteria check that requires Emperator success. Jenkins: Use a pipeline stage with sh 'emperor apply --strict' and archive reports for compliance review. 4. Generate and publish SBOMs \u00b6 Run emperor sbom --format cyclonedx --output sbom/app.json after successful checks. Upload SBOM artefacts ( actions/upload-artifact , gitlab-ci artifacts , etc.) and attach them to release pipelines. Feed SBOMs into vulnerability scanners (such as Dependency-Track) to maintain continuous monitoring. 5. Capture provenance \u00b6 Generate in-toto attestations: emperor attest --out provenance/intoto.jsonl summarizing contract version, Emperator version, and applied rules. Sign artefacts using Sigstore Cosign or an internal PKI ( cosign attest --predicate provenance/intoto.jsonl image:tag ). Store signatures alongside release artefacts; auditors can later verify that code was produced under a known contract. 6. Handle exemptions in pipelines \u00b6 Configure Emperator to fail builds if an exemption lacks justification or has expired ( emperor check --strict --enforce-expiry ). Export exemption reports to dashboards so compliance teams can track outstanding waivers. 7. Monitor performance \u00b6 Cache Semgrep and CodeQL databases between runs to keep pipeline times low ( actions/cache works well for GitHub Actions). Run heavy CodeQL packs on nightly builds if PR pipelines need to be faster. Record key metrics (issues found, fixes applied, runtime) for trending; Emperator\u2019s JSON output can feed Grafana or DataDog dashboards. By aligning local enforcement, CI gates, SBOM generation, and provenance, you ensure Emperator\u2019s contract remains authoritative across the entire delivery pipeline.","title":"Integrate with CI/CD Pipelines"},{"location":"how-to/ci-integration/#integrating-emperator-with-cicd-pipelines","text":"Emperator\u2019s contract enforcement is most effective when it runs consistently from developer workstations through CI, release packaging, and provenance attestation. This guide walks through recommended checkpoints and automation patterns.","title":"Integrating Emperator with CI/CD Pipelines"},{"location":"how-to/ci-integration/#1-align-local-and-ci-workflows","text":"Install Emperator and supporting tools ( semgrep , codeql , formatters) in developer environments via pre-commit or language-specific toolchains. Add the pre-commit hook described in the tutorial so local commits run emperor apply --diff --color before code reaches the central repository. Encourage developers to run emperor check --strict --no-fix in feature branches to preview CI outcomes.","title":"1. Align local and CI workflows"},{"location":"how-to/ci-integration/#2-stage-checks-in-ci","text":"Use fast checks for pull requests and full checks for protected branches. flowchart TD A[Developer push] --> B[Pre-commit hook] B -->|passes| C[PR build] C --> D{Emperor mode} D -->|fast| E[semgrep diff \u2022 format validation] D -->|full| F[codeql pack \u2022 codemod dry-run \u2022 tests] E --> G[PR status checks] F --> G G --> H[Merge] H --> I[Release build] I --> J[Provenance & SBOM upload] Recommended modes: Fast (pull requests): emperor apply --diff --no-commit --fast with Semgrep diff scans, contract validation, and format checkers. Upload SARIF results for inline review comments. Full (mainline): emperor apply --strict plus emperor test --generators to run property-based tests or contract-driven scaffolds. Execute CodeQL query packs and produce SBOMs.","title":"2. Stage checks in CI"},{"location":"how-to/ci-integration/#3-github-actions-template","text":"The workspace already includes .github/workflows/docs-ci.yml for MkDocs. Extend with a job dedicated to Emperator: name : Emperator Compliance on : pull_request : branches : [ main ] push : branches : [ main ] jobs : emperator : runs-on : ubuntu-latest steps : - uses : actions/checkout@v4 - name : Set up Python uses : actions/setup-python@v4 with : python-version : '3.11' - name : Install Emperator toolchain run : | python -m pip install --upgrade pip pip install emperator-cli semgrep curl -sSL https://github.com/github/codeql-action/releases/latest/download/codeql-bundle-linux64.tar.gz \\ | tar -xz -C \"$HOME\" echo \"CODEQL_HOME=$HOME/codeql\" >> \"$GITHUB_ENV\" - name : Run fast contract checks run : emperator apply --diff --no-commit --fast - name : Upload SARIF if : always() uses : github/codeql-action/upload-sarif@v2 with : sarif_file : reports/emperator.sarif Adaptations for other CI systems: GitLab CI: Install dependencies in a shared job and cache the Emperator virtual environment. Use artifacts:reports:sast to surface SARIF output in merge requests. Azure DevOps: Integrate with pipeline tasks to upload SARIF; gate deployments by adding a quality criteria check that requires Emperator success. Jenkins: Use a pipeline stage with sh 'emperor apply --strict' and archive reports for compliance review.","title":"3. GitHub Actions template"},{"location":"how-to/ci-integration/#4-generate-and-publish-sboms","text":"Run emperor sbom --format cyclonedx --output sbom/app.json after successful checks. Upload SBOM artefacts ( actions/upload-artifact , gitlab-ci artifacts , etc.) and attach them to release pipelines. Feed SBOMs into vulnerability scanners (such as Dependency-Track) to maintain continuous monitoring.","title":"4. Generate and publish SBOMs"},{"location":"how-to/ci-integration/#5-capture-provenance","text":"Generate in-toto attestations: emperor attest --out provenance/intoto.jsonl summarizing contract version, Emperator version, and applied rules. Sign artefacts using Sigstore Cosign or an internal PKI ( cosign attest --predicate provenance/intoto.jsonl image:tag ). Store signatures alongside release artefacts; auditors can later verify that code was produced under a known contract.","title":"5. Capture provenance"},{"location":"how-to/ci-integration/#6-handle-exemptions-in-pipelines","text":"Configure Emperator to fail builds if an exemption lacks justification or has expired ( emperor check --strict --enforce-expiry ). Export exemption reports to dashboards so compliance teams can track outstanding waivers.","title":"6. Handle exemptions in pipelines"},{"location":"how-to/ci-integration/#7-monitor-performance","text":"Cache Semgrep and CodeQL databases between runs to keep pipeline times low ( actions/cache works well for GitHub Actions). Run heavy CodeQL packs on nightly builds if PR pipelines need to be faster. Record key metrics (issues found, fixes applied, runtime) for trending; Emperator\u2019s JSON output can feed Grafana or DataDog dashboards. By aligning local enforcement, CI gates, SBOM generation, and provenance, you ensure Emperator\u2019s contract remains authoritative across the entire delivery pipeline.","title":"7. Monitor performance"},{"location":"includes/copilot-prompts/","text":"Copilot Prompt Patterns \u00b6 Prime Copilot (or any embedded assistant) with these reusable prompt packs so it can respect the Emperator contract, safety envelope, and governance workflows. Inline the relevant sections in .cursorrules , .vscode/settings.json , or your preferred prompt include mechanism. Contract authoring \u00b6 You maintain the Emperator Project Contract. Goal: extend the contract with a new rule. Checklist: - Reference current contract structure (see docs/reference/contract-spec.md). - Express constraints using CUE for configuration, Rego for policy, or OpenAPI for HTTP contracts. - Provide unit samples that trigger PASS/FAIL for the new rule. - Update CHANGELOG.md with rule id, rationale, and evidence links. Output: - Proposed contract snippet(s). - Minimal test fixtures. - Review notes for governance approval. Codemod and refactor planning \u00b6 You are Emperator\u2019s refactoring planner. Context: - Contract rule: {{ rule.id }} \u2014 {{ rule.description }} - Safety tier: {{ rule.tier }} (auto if low, otherwise review-only) - Tooling: LibCST, OpenRewrite, Ruff Instructions: - Describe the transformation in English, ensuring idempotence. - Provide a LibCST or OpenRewrite recipe skeleton when feasible. - Highlight validation steps (static analysis rerun, property-based tests). - Note rollback strategy if verification fails. AI-assisted fix requests \u00b6 Role: Local LLM assistant invoked by Emperator. Task: Produce a unified diff that resolves the flagged issue while staying within the contract. Inputs: - Offending code block - Contract excerpt and evidence links - Acceptance criteria/tests Rules: - Never introduce new dependencies without contract approval. - Preserve public APIs and documented side effects. - Add TODOs only when human follow-up is required, include rule id in comment. Return only the diff plus a one-line summary. Governance reviews \u00b6 You are conducting an Emperator waiver review. For each exemption in contract/exemptions.yaml: - Verify owner, expiry, and mitigation fields are present. - Confirm justification references the corresponding rule id and evidence. - Flag items expiring within 14 days. - Summarize residual risk and next action. Output a table with columns: Rule, Owner, Expiry, Status, Notes. Pull request checklist \u00b6 Reviewer mode: Ensure the change complies with the Emperator contract. Steps: 1. Confirm `emperor apply --diff --no-commit` was run (look for provenance comment). 2. Check SARIF or Emperator report attachments for unresolved violations. 3. Validate SBOM/provenance artefacts attached if release-impacting. 4. Ensure AI-assisted diffs include model/version metadata. 5. Record review outcome with rule ids in the comments. Respond with PASS/REJECT plus actionable feedback. Tailor these patterns per team conventions and keep them versioned alongside the contract so Copilot can follow the latest governance rules.","title":"Copilot Prompt Patterns"},{"location":"includes/copilot-prompts/#copilot-prompt-patterns","text":"Prime Copilot (or any embedded assistant) with these reusable prompt packs so it can respect the Emperator contract, safety envelope, and governance workflows. Inline the relevant sections in .cursorrules , .vscode/settings.json , or your preferred prompt include mechanism.","title":"Copilot Prompt Patterns"},{"location":"includes/copilot-prompts/#contract-authoring","text":"You maintain the Emperator Project Contract. Goal: extend the contract with a new rule. Checklist: - Reference current contract structure (see docs/reference/contract-spec.md). - Express constraints using CUE for configuration, Rego for policy, or OpenAPI for HTTP contracts. - Provide unit samples that trigger PASS/FAIL for the new rule. - Update CHANGELOG.md with rule id, rationale, and evidence links. Output: - Proposed contract snippet(s). - Minimal test fixtures. - Review notes for governance approval.","title":"Contract authoring"},{"location":"includes/copilot-prompts/#codemod-and-refactor-planning","text":"You are Emperator\u2019s refactoring planner. Context: - Contract rule: {{ rule.id }} \u2014 {{ rule.description }} - Safety tier: {{ rule.tier }} (auto if low, otherwise review-only) - Tooling: LibCST, OpenRewrite, Ruff Instructions: - Describe the transformation in English, ensuring idempotence. - Provide a LibCST or OpenRewrite recipe skeleton when feasible. - Highlight validation steps (static analysis rerun, property-based tests). - Note rollback strategy if verification fails.","title":"Codemod and refactor planning"},{"location":"includes/copilot-prompts/#ai-assisted-fix-requests","text":"Role: Local LLM assistant invoked by Emperator. Task: Produce a unified diff that resolves the flagged issue while staying within the contract. Inputs: - Offending code block - Contract excerpt and evidence links - Acceptance criteria/tests Rules: - Never introduce new dependencies without contract approval. - Preserve public APIs and documented side effects. - Add TODOs only when human follow-up is required, include rule id in comment. Return only the diff plus a one-line summary.","title":"AI-assisted fix requests"},{"location":"includes/copilot-prompts/#governance-reviews","text":"You are conducting an Emperator waiver review. For each exemption in contract/exemptions.yaml: - Verify owner, expiry, and mitigation fields are present. - Confirm justification references the corresponding rule id and evidence. - Flag items expiring within 14 days. - Summarize residual risk and next action. Output a table with columns: Rule, Owner, Expiry, Status, Notes.","title":"Governance reviews"},{"location":"includes/copilot-prompts/#pull-request-checklist","text":"Reviewer mode: Ensure the change complies with the Emperator contract. Steps: 1. Confirm `emperor apply --diff --no-commit` was run (look for provenance comment). 2. Check SARIF or Emperator report attachments for unresolved violations. 3. Validate SBOM/provenance artefacts attached if release-impacting. 4. Ensure AI-assisted diffs include model/version metadata. 5. Record review outcome with rule ids in the comments. Respond with PASS/REJECT plus actionable feedback. Tailor these patterns per team conventions and keep them versioned alongside the contract so Copilot can follow the latest governance rules.","title":"Pull request checklist"},{"location":"reference/contract-spec/","text":"Project Contract Reference \u00b6 Use this page to look up the canonical structure, rule metadata fields, severity tiers, and exemption syntax for Emperator contracts. Treat it as the contract maintainer\u2019s quick reference. Directory layout \u00b6 Path Description contract/conventions.cue CUE schemas for naming conventions, file layout, formatter preferences, and architectural wiring. contract/api/ OpenAPI or GraphQL interface specs that drive scaffolding and contract-aware tests. contract/policy/ OPA Rego modules defining deny/warn rules, dependency allowlists, and governance policies. contract/generators/ Codemod recipes, code templates, and scaffolding scripts keyed by language and rule. contract/exemptions.yaml Optional registry of approved waivers with owner, expiry, and mitigation notes. contract/README.md Human-readable change log, review checklist, and links to external standards. Protobuf schemas \u00b6 Store .proto files either under contract/api/ or the service repository\u2019s source tree and reference them from the contract via relative paths. Run buf format and buf lint as part of contract validation so code generation and API compatibility checks stay aligned with the Toolchain Matrix . Version generated language bindings (Go, Java, C#) through Emperator scaffolds to maintain parity between the canonical schema and downstream usage. Rule metadata schema \u00b6 Each rule compiled from the contract exposes the following fields in Emperator outputs and reports: Field Meaning id Stable identifier (e.g., LayeringPolicy.ControllerToDB ). Use dot notation for hierarchy. description Concise explanation shown in diagnostics. Include the \u201cwhy\u201d and reference to standards where relevant. source File and section inside the contract (e.g., conventions.cue#controllers.allowImports ). severity info , low , medium , high , or critical . Drives CI gating and alert styling. auto_apply true / false . Indicates whether Emperator may execute deterministic fixes without human approval. safety_tier formatting , low , medium , high . Governs downstream automation (AI assistants, codemod runners). evidence Optional citation list (URLs or doc references) supporting the rule rationale. tags Keyword array (e.g., security , style , compliance ) for filtering dashboards and reports. Rules authored in CUE, Rego, or metadata YAML should populate these fields so Emperator can render uniform diagnostics. Severity guidance \u00b6 Severity When to use Default enforcement info Advisory checks, upcoming policies, style suggestions with known exceptions. Logged only; no CI failure. low Minor hygiene issues with safe autofixes (e.g., formatting drift). Auto-fix and continue. medium Issues that may cause maintainability problems or mild security risks. Block CI until resolved or justified. high Significant security, compliance, or architectural violations. Fail CI, raise blocker in PR, optional auto-fix if deterministic. critical Actively exploitable security flaws or policy breaches that must not ship. Immediate failure; require manual remediation and sign-off. Exemption syntax \u00b6 Apply exemptions sparingly and always include justification plus expiry metadata. # emperator:ignore LayeringPolicy.ControllerToDB -- justification=\"Legacy module awaiting service rewrite\" -- expires=\"2025-12-31\" def legacy_handler (): ... Place ignore annotations on the minimal scope (line, block, or file). Emperator will record the exemption in reports. Exemptions without justification or expires are rejected when emperor check --strict --enforce-expiry runs. Track long-lived waivers in contract/exemptions.yaml : - rule : LayeringPolicy.ControllerToDB location : src/legacy/orders_controller.py:42 owner : platform-team justification : Temporary waiver while migrating to OrderService expires : 2025-12-31 Contract review checklist \u00b6 Run cue fmt and cue vet contract/conventions.cue to ensure structural validity. Execute opa check on Rego modules and run opa eval against sample findings. Dry-run Emperator ( emperor apply --diff --no-commit --fast ) to see the impact of new rules. Update docs/includes/copilot-prompts.md with new rule exemplars. Increment the contract version tag and note changes in contract/README.md . Keep this reference close during contract updates to ensure every rule remains actionable, auditable, and aligned with the wider engineering standards.","title":"Project Contract Reference"},{"location":"reference/contract-spec/#project-contract-reference","text":"Use this page to look up the canonical structure, rule metadata fields, severity tiers, and exemption syntax for Emperator contracts. Treat it as the contract maintainer\u2019s quick reference.","title":"Project Contract Reference"},{"location":"reference/contract-spec/#directory-layout","text":"Path Description contract/conventions.cue CUE schemas for naming conventions, file layout, formatter preferences, and architectural wiring. contract/api/ OpenAPI or GraphQL interface specs that drive scaffolding and contract-aware tests. contract/policy/ OPA Rego modules defining deny/warn rules, dependency allowlists, and governance policies. contract/generators/ Codemod recipes, code templates, and scaffolding scripts keyed by language and rule. contract/exemptions.yaml Optional registry of approved waivers with owner, expiry, and mitigation notes. contract/README.md Human-readable change log, review checklist, and links to external standards.","title":"Directory layout"},{"location":"reference/contract-spec/#protobuf-schemas","text":"Store .proto files either under contract/api/ or the service repository\u2019s source tree and reference them from the contract via relative paths. Run buf format and buf lint as part of contract validation so code generation and API compatibility checks stay aligned with the Toolchain Matrix . Version generated language bindings (Go, Java, C#) through Emperator scaffolds to maintain parity between the canonical schema and downstream usage.","title":"Protobuf schemas"},{"location":"reference/contract-spec/#rule-metadata-schema","text":"Each rule compiled from the contract exposes the following fields in Emperator outputs and reports: Field Meaning id Stable identifier (e.g., LayeringPolicy.ControllerToDB ). Use dot notation for hierarchy. description Concise explanation shown in diagnostics. Include the \u201cwhy\u201d and reference to standards where relevant. source File and section inside the contract (e.g., conventions.cue#controllers.allowImports ). severity info , low , medium , high , or critical . Drives CI gating and alert styling. auto_apply true / false . Indicates whether Emperator may execute deterministic fixes without human approval. safety_tier formatting , low , medium , high . Governs downstream automation (AI assistants, codemod runners). evidence Optional citation list (URLs or doc references) supporting the rule rationale. tags Keyword array (e.g., security , style , compliance ) for filtering dashboards and reports. Rules authored in CUE, Rego, or metadata YAML should populate these fields so Emperator can render uniform diagnostics.","title":"Rule metadata schema"},{"location":"reference/contract-spec/#severity-guidance","text":"Severity When to use Default enforcement info Advisory checks, upcoming policies, style suggestions with known exceptions. Logged only; no CI failure. low Minor hygiene issues with safe autofixes (e.g., formatting drift). Auto-fix and continue. medium Issues that may cause maintainability problems or mild security risks. Block CI until resolved or justified. high Significant security, compliance, or architectural violations. Fail CI, raise blocker in PR, optional auto-fix if deterministic. critical Actively exploitable security flaws or policy breaches that must not ship. Immediate failure; require manual remediation and sign-off.","title":"Severity guidance"},{"location":"reference/contract-spec/#exemption-syntax","text":"Apply exemptions sparingly and always include justification plus expiry metadata. # emperator:ignore LayeringPolicy.ControllerToDB -- justification=\"Legacy module awaiting service rewrite\" -- expires=\"2025-12-31\" def legacy_handler (): ... Place ignore annotations on the minimal scope (line, block, or file). Emperator will record the exemption in reports. Exemptions without justification or expires are rejected when emperor check --strict --enforce-expiry runs. Track long-lived waivers in contract/exemptions.yaml : - rule : LayeringPolicy.ControllerToDB location : src/legacy/orders_controller.py:42 owner : platform-team justification : Temporary waiver while migrating to OrderService expires : 2025-12-31","title":"Exemption syntax"},{"location":"reference/contract-spec/#contract-review-checklist","text":"Run cue fmt and cue vet contract/conventions.cue to ensure structural validity. Execute opa check on Rego modules and run opa eval against sample findings. Dry-run Emperator ( emperor apply --diff --no-commit --fast ) to see the impact of new rules. Update docs/includes/copilot-prompts.md with new rule exemplars. Increment the contract version tag and note changes in contract/README.md . Keep this reference close during contract updates to ensure every rule remains actionable, auditable, and aligned with the wider engineering standards.","title":"Contract review checklist"},{"location":"reference/developer-tooling/","text":"Developer Tooling Reference \u00b6 Document the baseline workstation setup that keeps Emperator contributors fast, consistent, and offline-friendly. Pair this page with the Toolchain Matrix and the Developer Experience overview when onboarding new teammates or refreshing local environments. Baseline stack \u00b6 1. Editor workflow (reproducible, LSP-centred) \u00b6 Rely on Language Server Protocol integrations in VS Code, Neovim, or any LSP-capable editor to surface completion, diagnostics, and codemod-ready code actions. Launch projects inside Dev Containers so the editor boots a pre-tooled environment described in devcontainer.json ; once cached locally the workflow stays reliable offline. Track shared formatting defaults via a root-level .editorconfig so secondary editors match the same indentation, end-of-line, and charset expectations. 2. Python lane (first-class) \u00b6 Use uv for package management and virtual environments. It is a drop-in pip replacement that produces a universal lockfile and delivers order-of-magnitude speedups. Run Ruff for both linting and formatting, aligning with the Python entry in the Toolchain Matrix . Pair it with pytest and coverage for fast unit feedback. Keep project environments self-contained. Export UV_VENV_IN_PROJECT=1 (or equivalent PIPENV_VENV_IN_PROJECT=1 / poetry config virtualenvs.in-project true ) so your virtual environments live under .venv/ inside the repository and can be pruned with a single rm -rf . 3. TypeScript and JavaScript \u00b6 Prefer pnpm workspaces for installs; they keep disk usage low and caching predictable across Dev Containers and CI. Reach for Biome when a single binary can handle lint and format. If framework plugins or bespoke rules are required, fall back to the ESLint plus Prettier combo referenced in the Toolchain Matrix . Use the repo-scoped .npmrc (sets store-dir=./.pnpm-store ) so pnpm\u2019s content-addressable store remains under version control boundaries. Run pnpm store prune periodically if you need to reclaim disk space. 4. Git hooks, commit hygiene, and PR UX \u00b6 Wire up pre-commit (or Lefthook ) to run Ruff, Biome, ShellCheck, yamllint, and other fast checks before code reaches CI. Guard commit history with Conventional Commits and commitlint so releases and changelog automation remain deterministic. Upload SARIF artefacts during CI (see the CI integration playbook ) so findings annotate GitHub pull requests inline. Point PRE_COMMIT_HOME at ${REPO_ROOT}/.cache/pre-commit (or use .envrc ) to keep hook environments alongside the repo. The .gitignore already excludes .cache/ , so caches never show up as dirty files. 5. Terminal ergonomics (pleasant, practical) \u00b6 Keep the shell minimal yet high-signal: starship prompt, ripgrep , fzf , zoxide , bat , delta , lazygit , and glow . Every tool is CLI-first, fast, and runs offline, which keeps parity with Dev Containers and reduces surprises in air-gapped environments. 6. Optional but excellent \u00b6 Install VS Code extensions such as Error Lens for inline diagnostics and GitLens for history context. Build documentation with MkDocs Material (this site) or Sphinx; embed architecture visuals with Mermaid. Align prose and code styling through .editorconfig and the docs lint tooling captured in the automation section of the Toolchain Matrix . Nice visual touches without noise \u00b6 Tune Error Lens severity colouring and gutter hints so inline diagnostics highlight actionable issues without creating a red wall. Surface inline blame and change history via GitLens to avoid tab-hopping during reviews and refactors. Enable git -c core.pager=delta show (or configure delta globally) for readable terminal diffs that highlight syntax, hunk movement, and word changes. Expose Ruff and Biome quick-fixes through the LSP code action menu so deterministic auto-fixes feel instant while staying under the safety gate described in the AI-assisted refactors guide . Publish PR check summaries with deep links and SARIF annotations so reviewers can jump from dashboards directly to highlighted code in GitHub. Keep this reference close when setting up new workstations, codifying pre-commit hooks, or refreshing Dev Container definitions. Every recommendation keeps velocity high without compromising the guardrails enforced elsewhere in the Emperator stack. Local cache hygiene \u00b6 .pnpm-store/ holds pnpm\u2019s shared packages for this project; delete the folder to force a clean reinstall. .cache/pre-commit/ retains hook environments; run PRE_COMMIT_HOME=$PWD/.cache/pre-commit pre-commit clean to reclaim space. .cache/pip/ (or UV\u2019s cache) can be relocated alongside the project with PIP_CACHE_DIR=$PWD/.cache/pip , ensuring global home directories stay lean.","title":"Developer Tooling Reference"},{"location":"reference/developer-tooling/#developer-tooling-reference","text":"Document the baseline workstation setup that keeps Emperator contributors fast, consistent, and offline-friendly. Pair this page with the Toolchain Matrix and the Developer Experience overview when onboarding new teammates or refreshing local environments.","title":"Developer Tooling Reference"},{"location":"reference/developer-tooling/#baseline-stack","text":"","title":"Baseline stack"},{"location":"reference/developer-tooling/#editor-workflow","text":"Rely on Language Server Protocol integrations in VS Code, Neovim, or any LSP-capable editor to surface completion, diagnostics, and codemod-ready code actions. Launch projects inside Dev Containers so the editor boots a pre-tooled environment described in devcontainer.json ; once cached locally the workflow stays reliable offline. Track shared formatting defaults via a root-level .editorconfig so secondary editors match the same indentation, end-of-line, and charset expectations.","title":"1. Editor workflow (reproducible, LSP-centred)"},{"location":"reference/developer-tooling/#python-lane","text":"Use uv for package management and virtual environments. It is a drop-in pip replacement that produces a universal lockfile and delivers order-of-magnitude speedups. Run Ruff for both linting and formatting, aligning with the Python entry in the Toolchain Matrix . Pair it with pytest and coverage for fast unit feedback. Keep project environments self-contained. Export UV_VENV_IN_PROJECT=1 (or equivalent PIPENV_VENV_IN_PROJECT=1 / poetry config virtualenvs.in-project true ) so your virtual environments live under .venv/ inside the repository and can be pruned with a single rm -rf .","title":"2. Python lane (first-class)"},{"location":"reference/developer-tooling/#typescript-javascript","text":"Prefer pnpm workspaces for installs; they keep disk usage low and caching predictable across Dev Containers and CI. Reach for Biome when a single binary can handle lint and format. If framework plugins or bespoke rules are required, fall back to the ESLint plus Prettier combo referenced in the Toolchain Matrix . Use the repo-scoped .npmrc (sets store-dir=./.pnpm-store ) so pnpm\u2019s content-addressable store remains under version control boundaries. Run pnpm store prune periodically if you need to reclaim disk space.","title":"3. TypeScript and JavaScript"},{"location":"reference/developer-tooling/#git-hygiene","text":"Wire up pre-commit (or Lefthook ) to run Ruff, Biome, ShellCheck, yamllint, and other fast checks before code reaches CI. Guard commit history with Conventional Commits and commitlint so releases and changelog automation remain deterministic. Upload SARIF artefacts during CI (see the CI integration playbook ) so findings annotate GitHub pull requests inline. Point PRE_COMMIT_HOME at ${REPO_ROOT}/.cache/pre-commit (or use .envrc ) to keep hook environments alongside the repo. The .gitignore already excludes .cache/ , so caches never show up as dirty files.","title":"4. Git hooks, commit hygiene, and PR UX"},{"location":"reference/developer-tooling/#terminal-ergonomics","text":"Keep the shell minimal yet high-signal: starship prompt, ripgrep , fzf , zoxide , bat , delta , lazygit , and glow . Every tool is CLI-first, fast, and runs offline, which keeps parity with Dev Containers and reduces surprises in air-gapped environments.","title":"5. Terminal ergonomics (pleasant, practical)"},{"location":"reference/developer-tooling/#optional-additions","text":"Install VS Code extensions such as Error Lens for inline diagnostics and GitLens for history context. Build documentation with MkDocs Material (this site) or Sphinx; embed architecture visuals with Mermaid. Align prose and code styling through .editorconfig and the docs lint tooling captured in the automation section of the Toolchain Matrix .","title":"6. Optional but excellent"},{"location":"reference/developer-tooling/#visual-touches","text":"Tune Error Lens severity colouring and gutter hints so inline diagnostics highlight actionable issues without creating a red wall. Surface inline blame and change history via GitLens to avoid tab-hopping during reviews and refactors. Enable git -c core.pager=delta show (or configure delta globally) for readable terminal diffs that highlight syntax, hunk movement, and word changes. Expose Ruff and Biome quick-fixes through the LSP code action menu so deterministic auto-fixes feel instant while staying under the safety gate described in the AI-assisted refactors guide . Publish PR check summaries with deep links and SARIF annotations so reviewers can jump from dashboards directly to highlighted code in GitHub. Keep this reference close when setting up new workstations, codifying pre-commit hooks, or refreshing Dev Container definitions. Every recommendation keeps velocity high without compromising the guardrails enforced elsewhere in the Emperator stack.","title":"Nice visual touches without noise"},{"location":"reference/developer-tooling/#local-cache-hygiene","text":".pnpm-store/ holds pnpm\u2019s shared packages for this project; delete the folder to force a clean reinstall. .cache/pre-commit/ retains hook environments; run PRE_COMMIT_HOME=$PWD/.cache/pre-commit pre-commit clean to reclaim space. .cache/pip/ (or UV\u2019s cache) can be relocated alongside the project with PIP_CACHE_DIR=$PWD/.cache/pip , ensuring global home directories stay lean.","title":"Local cache hygiene"},{"location":"reference/governance/","text":"Governance and Compliance Controls \u00b6 Emperator reinforces software governance by generating auditable artefacts, enforcing policy-as-code, and keeping a verifiable trail of every automated change. This reference outlines the key mechanisms teams rely on during audits and compliance reviews. SBOM production and validation \u00b6 Run emperor sbom --format cyclonedx --output sbom/app.json in CI after successful checks. Merge application SBOMs with base image or infrastructure SBOMs to achieve full-stack visibility. Feed generated SBOMs into vulnerability management platforms (Dependency-Track, Azure Defender, etc.) for continuous monitoring. Configure contract policies to block disallowed licenses or aged dependencies by querying SBOM metadata in OPA. Artefact Format Purpose Application SBOM CycloneDX JSON Documents runtime dependencies for audit trails and CVE scans. Contract SBOM SPDX Captures tools, codemod recipes, and templates used in enforcement. Combined SBOM CycloneDX BOM-Link Links application and infrastructure SBOMs for end-to-end provenance. Provenance and attestations \u00b6 Use emperor attest --out provenance/intoto.jsonl to emit in-toto statements describing the contract version, Emperator release, and rule outcomes. Sign attestations with Sigstore Cosign ( cosign attest --predicate provenance/intoto.jsonl image:tag ) or an internal PKI for regulated environments. Store signed attestations alongside release artefacts so auditors can verify origin and integrity. Include hashes of generated reports (SARIF, SBOM) inside the attestation payload for tamper evidence. Policy enforcement with OPA \u00b6 Maintain a dedicated policy package (e.g., contract/policy/compliance.rego ) that evaluates Emperator findings and SBOM data for compliance thresholds. Example rules: Fail builds when critical security findings remain unresolved. Require justification tags for auto-fixes applied to high or critical rules. Deny merges when contract exemptions exceed a predefined count or expiry window. Evaluate policies both locally ( opa eval ) and in CI to ensure consistent decisions across environments. Exemption governance \u00b6 Collect all approved waivers in contract/exemptions.yaml with owner, expiry, and mitigation plan. Schedule a recurring review (e.g., monthly) where compliance leads confirm whether exemptions can be retired. Set emperor check --strict --enforce-expiry in protected branch pipelines to prevent stale waivers from slipping through. Export exemption reports via emperor explain --format json and feed them into dashboards for executive visibility. Audit-ready logging \u00b6 Retain Emperator execution logs with timestamps, rule IDs, auto-fix decisions, and evidence links. Forward logs to a centralized system (Splunk, Elastic) for retention policies. Use the --format json option to store machine-readable results that can be cross-referenced with ticketing systems. Leverage the docs/includes/copilot-prompts.md prompts to ensure human reviewers mention rule IDs and contract versions in review comments, improving traceability. Documentation standards \u00b6 Keep contracts and documentation tightly coupled by updating the Toolchain Matrix and AI prompt include whenever enforcement rules change. Use the repository\u2019s documentation CI ( mkdocs build --strict , markdownlint-cli2 , lychee ) to fail fast on broken links or style regressions. Mirror CI checks locally via npx markdownlint-cli2 \"docs/**/*.md\" and lychee --config .lychee.toml docs so contributors catch issues before opening a pull request. Language owners \u00b6 Assign a steward for each language/platform (Python, JVM, JS/TS, Go, Rust, Infrastructure) to review new rules and formatter changes. Document ownership in the Project Contract metadata and reference it from team onboarding guides, ensuring contributors know who approves rule updates. Schedule quarterly syncs between language owners and product security to evaluate lint noise, codemod quality, and roadmap adjustments. Compliance checklist \u00b6 Contract change log updated with rationale and reviewer approvals. Latest SBOMs generated, signed, and archived per release. Attestations attached to build artefacts with verifiable signatures. Exemptions reviewed within SLA and annotated with next steps. SARIF/SAST reports stored for the required compliance retention window. Evidence pack (contract, prompts, test results) bundled for external audits. Following these practices ensures Emperator\u2019s automation not only keeps codebases healthy but also provides the documentation and traceability auditors expect.","title":"Governance and Compliance Controls"},{"location":"reference/governance/#governance-and-compliance-controls","text":"Emperator reinforces software governance by generating auditable artefacts, enforcing policy-as-code, and keeping a verifiable trail of every automated change. This reference outlines the key mechanisms teams rely on during audits and compliance reviews.","title":"Governance and Compliance Controls"},{"location":"reference/governance/#sbom-production-and-validation","text":"Run emperor sbom --format cyclonedx --output sbom/app.json in CI after successful checks. Merge application SBOMs with base image or infrastructure SBOMs to achieve full-stack visibility. Feed generated SBOMs into vulnerability management platforms (Dependency-Track, Azure Defender, etc.) for continuous monitoring. Configure contract policies to block disallowed licenses or aged dependencies by querying SBOM metadata in OPA. Artefact Format Purpose Application SBOM CycloneDX JSON Documents runtime dependencies for audit trails and CVE scans. Contract SBOM SPDX Captures tools, codemod recipes, and templates used in enforcement. Combined SBOM CycloneDX BOM-Link Links application and infrastructure SBOMs for end-to-end provenance.","title":"SBOM production and validation"},{"location":"reference/governance/#provenance-and-attestations","text":"Use emperor attest --out provenance/intoto.jsonl to emit in-toto statements describing the contract version, Emperator release, and rule outcomes. Sign attestations with Sigstore Cosign ( cosign attest --predicate provenance/intoto.jsonl image:tag ) or an internal PKI for regulated environments. Store signed attestations alongside release artefacts so auditors can verify origin and integrity. Include hashes of generated reports (SARIF, SBOM) inside the attestation payload for tamper evidence.","title":"Provenance and attestations"},{"location":"reference/governance/#policy-enforcement-with-opa","text":"Maintain a dedicated policy package (e.g., contract/policy/compliance.rego ) that evaluates Emperator findings and SBOM data for compliance thresholds. Example rules: Fail builds when critical security findings remain unresolved. Require justification tags for auto-fixes applied to high or critical rules. Deny merges when contract exemptions exceed a predefined count or expiry window. Evaluate policies both locally ( opa eval ) and in CI to ensure consistent decisions across environments.","title":"Policy enforcement with OPA"},{"location":"reference/governance/#managing-exemptions","text":"Collect all approved waivers in contract/exemptions.yaml with owner, expiry, and mitigation plan. Schedule a recurring review (e.g., monthly) where compliance leads confirm whether exemptions can be retired. Set emperor check --strict --enforce-expiry in protected branch pipelines to prevent stale waivers from slipping through. Export exemption reports via emperor explain --format json and feed them into dashboards for executive visibility.","title":"Exemption governance"},{"location":"reference/governance/#audit-ready-logging","text":"Retain Emperator execution logs with timestamps, rule IDs, auto-fix decisions, and evidence links. Forward logs to a centralized system (Splunk, Elastic) for retention policies. Use the --format json option to store machine-readable results that can be cross-referenced with ticketing systems. Leverage the docs/includes/copilot-prompts.md prompts to ensure human reviewers mention rule IDs and contract versions in review comments, improving traceability.","title":"Audit-ready logging"},{"location":"reference/governance/#documentation-standards","text":"Keep contracts and documentation tightly coupled by updating the Toolchain Matrix and AI prompt include whenever enforcement rules change. Use the repository\u2019s documentation CI ( mkdocs build --strict , markdownlint-cli2 , lychee ) to fail fast on broken links or style regressions. Mirror CI checks locally via npx markdownlint-cli2 \"docs/**/*.md\" and lychee --config .lychee.toml docs so contributors catch issues before opening a pull request.","title":"Documentation standards"},{"location":"reference/governance/#language-owners","text":"Assign a steward for each language/platform (Python, JVM, JS/TS, Go, Rust, Infrastructure) to review new rules and formatter changes. Document ownership in the Project Contract metadata and reference it from team onboarding guides, ensuring contributors know who approves rule updates. Schedule quarterly syncs between language owners and product security to evaluate lint noise, codemod quality, and roadmap adjustments.","title":"Language owners"},{"location":"reference/governance/#compliance-checklist","text":"Contract change log updated with rationale and reviewer approvals. Latest SBOMs generated, signed, and archived per release. Attestations attached to build artefacts with verifiable signatures. Exemptions reviewed within SLA and annotated with next steps. SARIF/SAST reports stored for the required compliance retention window. Evidence pack (contract, prompts, test results) bundled for external audits. Following these practices ensures Emperator\u2019s automation not only keeps codebases healthy but also provides the documentation and traceability auditors expect.","title":"Compliance checklist"},{"location":"reference/toolchain/","text":"Toolchain Matrix \u00b6 Reference chart for the analyzers, codemods, formatters, and CLI options Emperator orchestrates. Use it alongside the Getting Started tutorial , the Developer Tooling reference , and the System Architecture deep dive to map from contract capabilities to the concrete tooling each team needs. Static analysis support \u00b6 Language Tree-sitter CodeQL Semgrep Notes Python \u2714 \u2714 \u2714 Full stack with LibCST codemods and Ruff formatter (see AI-assisted refactors ). Java \u2714 \u2714 \u2714 Leverages OpenRewrite recipes for framework upgrades; tie into Implementation roadmap . JavaScript / TypeScript \u2714 Partial \u2714 CodeQL JS pack supports security queries; OpenRewrite JS recipes available; aligns with contract authoring guide . Go \u2714 \u2714 \u2714 gofmt integration for formatting; see CI integration playbook for caching guidance. C / C++ \u2714 \u2714 Partial Semgrep coverage limited to focused rules; clang-format handles formatting; reference Security and Safety posture . Ruby \u2714 \u2716 \u2714 Relies on Semgrep and Tree-sitter; consider Sorbet integration for deeper analysis. Shell \u2714 \u2716 \u2714 Static analysis limited to Semgrep patterns and shellcheck (optional plugin); pair with Developer experience guardrails . Codemod engines \u00b6 Ecosystem Engine Typical use cases Safety tier guidance Python LibCST API migrations, string formatting upgrades, import normalization. formatting or low by default; raise to medium for behavioural changes. JVM (Java/Kotlin) OpenRewrite Dependency upgrades, Spring migrations, logging refactors. low \u2013 medium depending on recipe maturity. JavaScript/TypeScript TS AST + OpenRewrite JS Deprecated API replacements, lint autofixes. low when AST transform is deterministic. YAML / XML OpenRewrite Configuration rewrites (Kubernetes manifests, Maven POM). low (structure-preserving). Go Custom go/ast transforms Interface renames, dependency injection wiring. medium unless validated by tests. C/C++ Clang-Tidy refactors Modernization (auto, nullptr), includes reorder. medium due to potential macro interactions. Formatter integrations \u00b6 Language Formatter Invocation Python Ruff / Black ruff check --fix (primary) with optional black fallback. JavaScript / TypeScript Prettier prettier --write respecting contract-defined settings. Java google-java-format or Spotless Configured via contract metadata. Go gofmt gofmt -w with module-aware path filtering. C / C++ clang-format Style file generated from contract defaults. Markdown / YAML mdformat / prettier Keeps documentation and config consistent with docs build. CLI highlights \u00b6 Command Purpose Notes emperor apply Compile contract, run checks, apply safe fixes, and re-validate. Use --diff , --no-commit , --fast , or --strict depending on context. emperor check Run checks without applying fixes. Pair with --format sarif for CI uploads. emperor explain Show provenance of the last run (contract version, applied rules, AI model metadata). Helpful when auditing AI-assisted changes or exemption usage. emperor sbom Generate CycloneDX or SPDX SBOMs from dependency manifests and IR metadata. Supports --format cyclonedx\\|spdx and --output path options. emperor attest Produce in-toto attestations capturing rule enforcement and tool versions. Combine with Sigstore Cosign for signed provenance. emperor ai suggest Request AI-generated fixes for a finding set. Respects rule safety tiers and always triggers the validation loop. Environment variables \u00b6 Variable Effect EMPERATOR_CONTRACT_PATH Override default contract/ directory. Useful for monorepos. EMPERATOR_CACHE_DIR Set location for IR caches (Tree-sitter, CodeQL). Configure in CI for faster reruns. EMPERATOR_AI_ENABLED Toggle AI-assisted workflows ( 0 or 1 ). EMPERATOR_STRICT_MODE Force --strict behaviour even if CLI flag omitted (handy in protected branches). EMPERATOR_TRACE Enable verbose logging for debugging integration issues. Recommended lint and formatter stacks \u00b6 Ecosystem Primary tooling Notes Python Ruff ( ruff check , ruff format ) Drop-in for Flake8/Black/isort with 10\u2013100\u00d7 speedups; see the AI-assisted refactors how-to for Ruff-aware codemods. JavaScript / TypeScript (Track A) ESLint + Prettier Default pairing across most projects; Prettier also covers JSON, YAML, Markdown; referenced in the Developer experience overview . JavaScript / TypeScript (Track B) Biome Single binary for lint + format with safe/unsafe fix modes; ideal for air-gapped environments described in System architecture . Go gofmt + golangci-lint gofmt enforces canonical style; golangci-lint aggregates fast parallel linters, matching the CI integration guide . Java google-java-format + Error Prone Deterministic formatting with compile-time bug pattern checks; add Spotless as wrapper if needed (see Implementation roadmap ). Kotlin ktlint + detekt ktlint enforces Kotlin style; detekt flags code smells and supports baselining legacy issues\u2014baseline workflow covered in Governance reference . Rust rustfmt + Clippy Shipping defaults that encode community idioms and over 750 lint rules; evaluate findings via Security and Safety posture . C / C++ clang-format + clang-tidy clang-format standardizes layout; clang-tidy provides static analysis and modernization checks, complementing System architecture . Shell shfmt + ShellCheck shfmt for consistent indentation; ShellCheck for common shell pitfalls; rollout tips in Implementation roadmap . Protobuf buf format + buf lint Ensures consistent style and forward-compatible API design; integrates with Contract spec reference . Terraform terraform fmt + TFLint Canonical formatting plus provider-aware linting and security checks; see DevSecOps supply chain . Dockerfiles hadolint AST-based linting that also shells through to ShellCheck for RUN commands; reference Security and Safety posture . YAML / JSON / Markdown Prettier + yamllint + markdownlint Prettier handles structure; yamllint and markdownlint enforce semantics; aligns with Docs governance . TOML Taplo Formatter and LSP support for manifests (Cargo, Config); tie into Developer experience . .NET / C# dotnet format + Roslyn analyzers Aligns with .editorconfig ; Roslyn analyzers supply style and quality rules, mapped to Contract governance . Related playbooks \u00b6 Get a hands-on walkthrough in the Getting Started tutorial . Embed these checks in delivery pipelines with the CI/CD integration guide . Author new standards using the Contract authoring guide and tie them back to this matrix. Explore architecture rationale in System Architecture and Developer Experience . Tune rollout sequencing with the Implementation roadmap and Governance reference . Automation to keep this reference current \u00b6 The repository\u2019s Docs CI workflow now runs mkdocs build --strict , markdownlint-cli2 , and lychee to catch formatting drift, lint violations, and broken links before merge. Configuration lives alongside the docs ( .markdownlint.jsonc , .lychee.toml ) so teams can evolve rules with contract updates and share the same compliance defaults locally via npx markdownlint-cli2 and lychee --config .lychee.toml docs . Pair the CI checks with local pre-commit hooks (see CI/CD integration guide ) so editors, pipelines, and published docs stay synchronized. Keep this matrix updated as you expand language support or onboard new teams so everyone shares the same expectations about analyser coverage and automation guarantees.","title":"Toolchain Matrix"},{"location":"reference/toolchain/#toolchain-matrix","text":"Reference chart for the analyzers, codemods, formatters, and CLI options Emperator orchestrates. Use it alongside the Getting Started tutorial , the Developer Tooling reference , and the System Architecture deep dive to map from contract capabilities to the concrete tooling each team needs.","title":"Toolchain Matrix"},{"location":"reference/toolchain/#static-analysis-support","text":"Language Tree-sitter CodeQL Semgrep Notes Python \u2714 \u2714 \u2714 Full stack with LibCST codemods and Ruff formatter (see AI-assisted refactors ). Java \u2714 \u2714 \u2714 Leverages OpenRewrite recipes for framework upgrades; tie into Implementation roadmap . JavaScript / TypeScript \u2714 Partial \u2714 CodeQL JS pack supports security queries; OpenRewrite JS recipes available; aligns with contract authoring guide . Go \u2714 \u2714 \u2714 gofmt integration for formatting; see CI integration playbook for caching guidance. C / C++ \u2714 \u2714 Partial Semgrep coverage limited to focused rules; clang-format handles formatting; reference Security and Safety posture . Ruby \u2714 \u2716 \u2714 Relies on Semgrep and Tree-sitter; consider Sorbet integration for deeper analysis. Shell \u2714 \u2716 \u2714 Static analysis limited to Semgrep patterns and shellcheck (optional plugin); pair with Developer experience guardrails .","title":"Static analysis support"},{"location":"reference/toolchain/#codemod-engines","text":"Ecosystem Engine Typical use cases Safety tier guidance Python LibCST API migrations, string formatting upgrades, import normalization. formatting or low by default; raise to medium for behavioural changes. JVM (Java/Kotlin) OpenRewrite Dependency upgrades, Spring migrations, logging refactors. low \u2013 medium depending on recipe maturity. JavaScript/TypeScript TS AST + OpenRewrite JS Deprecated API replacements, lint autofixes. low when AST transform is deterministic. YAML / XML OpenRewrite Configuration rewrites (Kubernetes manifests, Maven POM). low (structure-preserving). Go Custom go/ast transforms Interface renames, dependency injection wiring. medium unless validated by tests. C/C++ Clang-Tidy refactors Modernization (auto, nullptr), includes reorder. medium due to potential macro interactions.","title":"Codemod engines"},{"location":"reference/toolchain/#formatter-integrations","text":"Language Formatter Invocation Python Ruff / Black ruff check --fix (primary) with optional black fallback. JavaScript / TypeScript Prettier prettier --write respecting contract-defined settings. Java google-java-format or Spotless Configured via contract metadata. Go gofmt gofmt -w with module-aware path filtering. C / C++ clang-format Style file generated from contract defaults. Markdown / YAML mdformat / prettier Keeps documentation and config consistent with docs build.","title":"Formatter integrations"},{"location":"reference/toolchain/#cli-highlights","text":"Command Purpose Notes emperor apply Compile contract, run checks, apply safe fixes, and re-validate. Use --diff , --no-commit , --fast , or --strict depending on context. emperor check Run checks without applying fixes. Pair with --format sarif for CI uploads. emperor explain Show provenance of the last run (contract version, applied rules, AI model metadata). Helpful when auditing AI-assisted changes or exemption usage. emperor sbom Generate CycloneDX or SPDX SBOMs from dependency manifests and IR metadata. Supports --format cyclonedx\\|spdx and --output path options. emperor attest Produce in-toto attestations capturing rule enforcement and tool versions. Combine with Sigstore Cosign for signed provenance. emperor ai suggest Request AI-generated fixes for a finding set. Respects rule safety tiers and always triggers the validation loop.","title":"CLI highlights"},{"location":"reference/toolchain/#environment-variables","text":"Variable Effect EMPERATOR_CONTRACT_PATH Override default contract/ directory. Useful for monorepos. EMPERATOR_CACHE_DIR Set location for IR caches (Tree-sitter, CodeQL). Configure in CI for faster reruns. EMPERATOR_AI_ENABLED Toggle AI-assisted workflows ( 0 or 1 ). EMPERATOR_STRICT_MODE Force --strict behaviour even if CLI flag omitted (handy in protected branches). EMPERATOR_TRACE Enable verbose logging for debugging integration issues.","title":"Environment variables"},{"location":"reference/toolchain/#recommended-lint-and-formatter-stacks","text":"Ecosystem Primary tooling Notes Python Ruff ( ruff check , ruff format ) Drop-in for Flake8/Black/isort with 10\u2013100\u00d7 speedups; see the AI-assisted refactors how-to for Ruff-aware codemods. JavaScript / TypeScript (Track A) ESLint + Prettier Default pairing across most projects; Prettier also covers JSON, YAML, Markdown; referenced in the Developer experience overview . JavaScript / TypeScript (Track B) Biome Single binary for lint + format with safe/unsafe fix modes; ideal for air-gapped environments described in System architecture . Go gofmt + golangci-lint gofmt enforces canonical style; golangci-lint aggregates fast parallel linters, matching the CI integration guide . Java google-java-format + Error Prone Deterministic formatting with compile-time bug pattern checks; add Spotless as wrapper if needed (see Implementation roadmap ). Kotlin ktlint + detekt ktlint enforces Kotlin style; detekt flags code smells and supports baselining legacy issues\u2014baseline workflow covered in Governance reference . Rust rustfmt + Clippy Shipping defaults that encode community idioms and over 750 lint rules; evaluate findings via Security and Safety posture . C / C++ clang-format + clang-tidy clang-format standardizes layout; clang-tidy provides static analysis and modernization checks, complementing System architecture . Shell shfmt + ShellCheck shfmt for consistent indentation; ShellCheck for common shell pitfalls; rollout tips in Implementation roadmap . Protobuf buf format + buf lint Ensures consistent style and forward-compatible API design; integrates with Contract spec reference . Terraform terraform fmt + TFLint Canonical formatting plus provider-aware linting and security checks; see DevSecOps supply chain . Dockerfiles hadolint AST-based linting that also shells through to ShellCheck for RUN commands; reference Security and Safety posture . YAML / JSON / Markdown Prettier + yamllint + markdownlint Prettier handles structure; yamllint and markdownlint enforce semantics; aligns with Docs governance . TOML Taplo Formatter and LSP support for manifests (Cargo, Config); tie into Developer experience . .NET / C# dotnet format + Roslyn analyzers Aligns with .editorconfig ; Roslyn analyzers supply style and quality rules, mapped to Contract governance .","title":"Recommended lint and formatter stacks"},{"location":"reference/toolchain/#related-playbooks","text":"Get a hands-on walkthrough in the Getting Started tutorial . Embed these checks in delivery pipelines with the CI/CD integration guide . Author new standards using the Contract authoring guide and tie them back to this matrix. Explore architecture rationale in System Architecture and Developer Experience . Tune rollout sequencing with the Implementation roadmap and Governance reference .","title":"Related playbooks"},{"location":"reference/toolchain/#automation-to-keep-this-reference-current","text":"The repository\u2019s Docs CI workflow now runs mkdocs build --strict , markdownlint-cli2 , and lychee to catch formatting drift, lint violations, and broken links before merge. Configuration lives alongside the docs ( .markdownlint.jsonc , .lychee.toml ) so teams can evolve rules with contract updates and share the same compliance defaults locally via npx markdownlint-cli2 and lychee --config .lychee.toml docs . Pair the CI checks with local pre-commit hooks (see CI/CD integration guide ) so editors, pipelines, and published docs stay synchronized. Keep this matrix updated as you expand language support or onboard new teams so everyone shares the same expectations about analyser coverage and automation guarantees.","title":"Automation to keep this reference current"},{"location":"tutorial/getting-started/","text":"Bootstrapping Emperator in a Repository \u00b6 This tutorial takes you from zero to a working Emperator run in a fresh repository. You will: Install the CLI and supporting toolchain. Author a minimal Project Contract that encodes one style rule and one security guardrail. Execute the Contract\u2192IR\u2192Action pipeline locally and review the resulting fixes and reports. Wire the command into a pre-commit hook so every change benefits from the same enforcement loop. Prerequisites \u00b6 Python 3.11+ with pip available on your workstation. Git installed for version control integration. Optional but recommended: Node.js 18+ if you plan to expand formatting support with additional ecosystem tools. A repo you can experiment with. The examples below assume a project root called sample-app . python -m pip install --upgrade pip pip install emperator-cli tree-sitter pymdown-extensions codeql-bundle semgrep ruff Note: codeql-bundle is a large dependency. If you cannot install it locally, skip for now and rely on Semgrep checks; you can add CodeQL later during CI integration. Step 1 \u2014 Initialize the contract directory \u00b6 Create a contract/ folder at the root of your repo. Emperator treats this as the executable specification for your standards. Start with three files that mirror the layers described in the architecture overview. contract/ \u251c\u2500\u2500 conventions.cue \u251c\u2500\u2500 policy/rules.rego \u2514\u2500\u2500 api/openapi.yaml Sample content: contract/conventions.cue package contract controllers: { files: [...string] & =~\"^[a-z0-9_]+\\.py$\" } contract/policy/rules.rego package contract . security deny [ msg ] { input . findings [ _ ]. rule == \"SecretDetection\" msg := \"Hardcoded secret detected\" } contract/api/openapi.yaml openapi : 3.1.0 info : title : Sample Service Contract version : 0.1.0 paths : /healthz : get : operationId : getHealth responses : '200' : description : OK Step 2 \u2014 Seed a code sample that violates the contract \u00b6 Add a small file that intentionally breaks your rules so you can observe Emperator in action. src/controllers/UserController.py from util import db def get_user (): token = \"AKIA-FAKE-KEY\" return db . query ( \"SELECT * FROM users WHERE id = 1\" ) The filename mixes casing, the code embeds a credential-like string, and the controller hits the database layer directly. Step 3 \u2014 Run emperor apply \u00b6 Execute the CLI at the project root to compile the contract, build the IR, and run checks. cd sample-app emperor apply --diff --format table Typical output after the first run: Emperator v1.0 \u2022 Contract revision 0.1.0 [Check] 3 issues found 1. NamingConvention: controllers/UserController.py \u2192 rename to snake_case 2. SecretDetection: Potential credential literal at line 4 3. LayeringPolicy: Direct DB access from controller at line 5 [Fix] Applied 1 autofix \u2714 Renamed controllers/UserController.py \u2192 controllers/user_controller.py [Suggest] 2 manual reviews required \u2757 Replace literal credential with vault reference \u2757 Route DB call through service layer Summary: 1 change applied, 2 suggestions pending review. Behind the scenes Emperator performed the following workflow: flowchart LR subgraph Contract Layer A[Project Contract<br/>(OpenAPI, CUE, Rego)] end subgraph IR Layer B[Tree-sitter CST<br/>+ CodeQL semantics<br/>+ Semgrep patterns] end subgraph Action Layer C1[Check Engines] C2[Fix Engines] C3[Formatters] end A --> B --> C1 C1 -->|violations| D{Safety Gate} D -->|Auto-fixable| C2 --> C3 --> E[Proposed or Applied Changes] D -->|Manual review| E E --> F[Re-check & Optional Tests] F -->|Pass| G[\u2705 Standards satisfied] F -->|Fail| H[Rollback & Report] Step 4 \u2014 Inspect diffs and apply suggestions \u00b6 Accept or modify Emperator\u2019s proposed rename (already applied). Replace the hardcoded credential with a secrets manager reference. Move the database call into a dedicated service module and expose a service method to the controller. Re-run emperor apply until the summary shows \u2705 Standards satisfied . Step 5 \u2014 Add a pre-commit hook \u00b6 Integrate Emperator with pre-commit so every developer receives the same enforcement locally. .pre-commit-config.yaml repos : - repo : local hooks : - id : emperator name : Emperator Standards Check entry : emperor apply --diff --color language : system pass_filenames : false Install the hook: pip install pre-commit pre-commit install Now any commit that breaks the contract will fail fast with actionable diagnostics. Next steps \u00b6 Expand the contract with additional rules from the how-to guides. Wire Emperator into CI using the pipeline recipes in Integrating Emperator with CI/CD Pipelines . Explore the architecture deep dive to understand how the IR stays synchronized across languages and how the safety envelope protects your code base.","title":"Bootstrapping Emperator in a Repository"},{"location":"tutorial/getting-started/#bootstrapping-emperator-in-a-repository","text":"This tutorial takes you from zero to a working Emperator run in a fresh repository. You will: Install the CLI and supporting toolchain. Author a minimal Project Contract that encodes one style rule and one security guardrail. Execute the Contract\u2192IR\u2192Action pipeline locally and review the resulting fixes and reports. Wire the command into a pre-commit hook so every change benefits from the same enforcement loop.","title":"Bootstrapping Emperator in a Repository"},{"location":"tutorial/getting-started/#prerequisites","text":"Python 3.11+ with pip available on your workstation. Git installed for version control integration. Optional but recommended: Node.js 18+ if you plan to expand formatting support with additional ecosystem tools. A repo you can experiment with. The examples below assume a project root called sample-app . python -m pip install --upgrade pip pip install emperator-cli tree-sitter pymdown-extensions codeql-bundle semgrep ruff Note: codeql-bundle is a large dependency. If you cannot install it locally, skip for now and rely on Semgrep checks; you can add CodeQL later during CI integration.","title":"Prerequisites"},{"location":"tutorial/getting-started/#step-1-initialize-the-contract-directory","text":"Create a contract/ folder at the root of your repo. Emperator treats this as the executable specification for your standards. Start with three files that mirror the layers described in the architecture overview. contract/ \u251c\u2500\u2500 conventions.cue \u251c\u2500\u2500 policy/rules.rego \u2514\u2500\u2500 api/openapi.yaml Sample content: contract/conventions.cue package contract controllers: { files: [...string] & =~\"^[a-z0-9_]+\\.py$\" } contract/policy/rules.rego package contract . security deny [ msg ] { input . findings [ _ ]. rule == \"SecretDetection\" msg := \"Hardcoded secret detected\" } contract/api/openapi.yaml openapi : 3.1.0 info : title : Sample Service Contract version : 0.1.0 paths : /healthz : get : operationId : getHealth responses : '200' : description : OK","title":"Step 1 \u2014 Initialize the contract directory"},{"location":"tutorial/getting-started/#step-2-seed-a-code-sample-that-violates-the-contract","text":"Add a small file that intentionally breaks your rules so you can observe Emperator in action. src/controllers/UserController.py from util import db def get_user (): token = \"AKIA-FAKE-KEY\" return db . query ( \"SELECT * FROM users WHERE id = 1\" ) The filename mixes casing, the code embeds a credential-like string, and the controller hits the database layer directly.","title":"Step 2 \u2014 Seed a code sample that violates the contract"},{"location":"tutorial/getting-started/#step-3-run-emperor-apply","text":"Execute the CLI at the project root to compile the contract, build the IR, and run checks. cd sample-app emperor apply --diff --format table Typical output after the first run: Emperator v1.0 \u2022 Contract revision 0.1.0 [Check] 3 issues found 1. NamingConvention: controllers/UserController.py \u2192 rename to snake_case 2. SecretDetection: Potential credential literal at line 4 3. LayeringPolicy: Direct DB access from controller at line 5 [Fix] Applied 1 autofix \u2714 Renamed controllers/UserController.py \u2192 controllers/user_controller.py [Suggest] 2 manual reviews required \u2757 Replace literal credential with vault reference \u2757 Route DB call through service layer Summary: 1 change applied, 2 suggestions pending review. Behind the scenes Emperator performed the following workflow: flowchart LR subgraph Contract Layer A[Project Contract<br/>(OpenAPI, CUE, Rego)] end subgraph IR Layer B[Tree-sitter CST<br/>+ CodeQL semantics<br/>+ Semgrep patterns] end subgraph Action Layer C1[Check Engines] C2[Fix Engines] C3[Formatters] end A --> B --> C1 C1 -->|violations| D{Safety Gate} D -->|Auto-fixable| C2 --> C3 --> E[Proposed or Applied Changes] D -->|Manual review| E E --> F[Re-check & Optional Tests] F -->|Pass| G[\u2705 Standards satisfied] F -->|Fail| H[Rollback & Report]","title":"Step 3 \u2014 Run emperor apply"},{"location":"tutorial/getting-started/#step-4-inspect-diffs-and-apply-suggestions","text":"Accept or modify Emperator\u2019s proposed rename (already applied). Replace the hardcoded credential with a secrets manager reference. Move the database call into a dedicated service module and expose a service method to the controller. Re-run emperor apply until the summary shows \u2705 Standards satisfied .","title":"Step 4 \u2014 Inspect diffs and apply suggestions"},{"location":"tutorial/getting-started/#step-5-add-a-pre-commit-hook","text":"Integrate Emperator with pre-commit so every developer receives the same enforcement locally. .pre-commit-config.yaml repos : - repo : local hooks : - id : emperator name : Emperator Standards Check entry : emperor apply --diff --color language : system pass_filenames : false Install the hook: pip install pre-commit pre-commit install Now any commit that breaks the contract will fail fast with actionable diagnostics.","title":"Step 5 \u2014 Add a pre-commit hook"},{"location":"tutorial/getting-started/#next-steps","text":"Expand the contract with additional rules from the how-to guides. Wire Emperator into CI using the pipeline recipes in Integrating Emperator with CI/CD Pipelines . Explore the architecture deep dive to understand how the IR stays synchronized across languages and how the safety envelope protects your code base.","title":"Next steps"}]}